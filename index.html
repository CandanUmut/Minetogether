<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DeepMine Online ¬∑ Mine Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #030712;
      --panel: #0b1220;
      --card: #0f172a;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.2);
      --danger: #f97373;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --radius: 18px;
      --glow: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(249, 115, 22, 0.12), transparent 30%);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #0b1220, #020617 55%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    .background-stars {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 10% 20%, rgba(56, 189, 248, 0.08), transparent 35%),
        radial-gradient(circle at 80% 10%, rgba(34, 197, 94, 0.06), transparent 30%),
        radial-gradient(circle at 40% 70%, rgba(239, 68, 68, 0.07), transparent 40%);
      opacity: 0.7;
      pointer-events: none;
      filter: blur(32px);
      z-index: 0;
    }

    .app {
      max-width: 1400px;
      width: 100%;
      padding: 32px 18px 42px;
      position: relative;
      z-index: 1;
    }

    .card-shell {
      position: relative;
      background: linear-gradient(145deg, rgba(17, 24, 39, 0.8), rgba(8, 47, 73, 0.8)), var(--card);
      border-radius: var(--radius);
      padding: 22px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(75, 85, 99, 0.4);
      backdrop-filter: blur(24px);
      overflow: hidden;
    }

    .card-shell > * { position: relative; z-index: 1; }

    .card-shell::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: var(--radius);
      background: var(--glow);
      pointer-events: none;
      opacity: 0.75;
      animation: panelGlow 14s ease-in-out infinite;
      z-index: 0;
    }

    h1 {
      margin-top: 0;
      font-size: 2rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    h1 span.icon { font-size: 2.2rem; }

    .subtitle {
      color: var(--text-soft);
      margin-bottom: 12px;
      max-width: 640px;
      font-size: 0.95rem;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 16px;
    }

    .col {
      flex: 1 1 260px;
      min-width: 0;
    }

    .col-wide {
      flex: 1.2 1 340px;
    }

    .section-title {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      margin-bottom: 6px;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: rgba(15, 23, 42, 0.95);
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
    }

    input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(to right, #22c55e, #38bdf8);
      color: #0f172a;
      box-shadow: 0 8px 25px rgba(56, 189, 248, 0.45);
      transition: transform 0.1s, box-shadow 0.1s;
      white-space: nowrap;
    }

    button.secondary {
      background: transparent;
      border: 1px solid #4b5563;
      color: var(--text-soft);
      box-shadow: none;
    }

    button.small {
      padding: 6px 10px;
      font-size: 0.78rem;
    }

    button[disabled] {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(75, 85, 99, 0.7);
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
    }

    .pill-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.7);
    }

    .pill.offline .pill-dot {
      background: #f97373;
      box-shadow: 0 0 8px rgba(248, 113, 113, 0.7);
    }

    .error {
      color: var(--danger);
      font-size: 0.8rem;
      margin-top: 6px;
    }

    /* THREE.JS PANEL */

    .mine-panel {
      border-radius: 16px;
      border: 1px solid rgba(59, 130, 246, 0.35);
      background: radial-gradient(circle at 30% -10%, #1d2536, #0a1120 55%, #05070f);
      padding: 10px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.8);
      min-height: 380px;
      isolation: isolate;
    }

    #mine-canvas {
      width: 100%;
      height: 360px;
      display: block;
      border-radius: 14px;
      background: transparent;
      filter: saturate(1.05);
    }

    @media (max-width: 600px) {
      #mine-canvas {
        height: 260px;
      }
    }

    .mine-panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(14, 116, 144, 0.15), transparent 30%, rgba(17, 24, 39, 0.5));
      z-index: 0;
      pointer-events: none;
    }

    .minimap-overlay {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 160px;
      height: 110px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      border-radius: 12px;
      pointer-events: none;
      background: rgba(8, 15, 28, 0.9);
      box-shadow: inset 0 0 14px rgba(14, 165, 233, 0.35);
      color: var(--text-soft);
      font-size: 0.75rem;
      padding: 4px 6px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 4px;
      backdrop-filter: blur(4px);
    }

    #minimap-map {
      width: 100%;
      height: 90px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.6));
    }

    .floating-container {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }

    .collapse-warning {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(185, 28, 28, 0.25);
      color: #fecdd3;
      font-weight: 700;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      backdrop-filter: blur(1px);
    }

    .collapse-warning.active {
      opacity: 1;
      pointer-events: none;
    }

    .floating-text {
      position: absolute;
      color: #facc15;
      font-weight: 700;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.45);
      opacity: 0;
      transition: transform 0.8s ease-out, opacity 0.8s ease-out;
      white-space: nowrap;
    }

    .dig-ripple {
      position: absolute;
      width: 120px;
      height: 120px;
      border-radius: 999px;
      background: radial-gradient(circle, rgba(248, 250, 252, 0.45), rgba(59, 130, 246, 0.05));
      opacity: 0.25;
      transform: translate(-50%, -50%) scale(0.2);
      pointer-events: none;
      filter: blur(1px);
      animation: ripplePulse 1s ease-out forwards;
    }

    .sound-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .toggle-btn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text);
      cursor: pointer;
      font-size: 0.82rem;
    }

    .toggle-btn.active {
      border-color: #38bdf8;
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.4);
      background: rgba(56, 189, 248, 0.1);
      color: #e0f2fe;
    }

    .mine-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .mine-tab {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text);
      cursor: pointer;
      font-size: 0.82rem;
      transition: transform 0.12s, box-shadow 0.12s, border-color 0.12s;
    }

    .mine-tab.active {
      border-color: #38bdf8;
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.35);
      background: rgba(56, 189, 248, 0.15);
      color: #e0f2fe;
    }

    .mine-tab.add {
      border-color: rgba(74, 222, 128, 0.6);
      color: #bbf7d0;
      background: rgba(22, 101, 52, 0.25);
    }

    .depth-hud {
      position: absolute;
      left: 12px;
      top: 12px;
      background: rgba(15, 23, 42, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 5px 10px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .depth-hud span.value {
      font-weight: 700;
      color: #facc15;
    }

    .resource-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.85rem;
      margin-top: 8px;
    }

    .resource-chip {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .resource-chip span.value {
      font-weight: 700;
    }

    .controls-card {
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: rgba(15, 23, 42, 0.96);
      padding: 10px 12px;
      font-size: 0.9rem;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.7);
    }

    .camera-panel {
      margin-top: 12px;
      border-radius: 14px;
      border: 1px solid rgba(56, 189, 248, 0.45);
      background: rgba(8, 15, 28, 0.9);
      padding: 10px 12px;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.7);
    }

    .camera-panel .panel-title {
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--text);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .camera-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }

    .camera-buttons button {
      background: rgba(56, 189, 248, 0.12);
      color: #e0f2fe;
      border: 1px solid rgba(56, 189, 248, 0.45);
      box-shadow: none;
    }

    .camera-buttons button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(56, 189, 248, 0.25);
    }

    .camera-move {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
      gap: 6px;
    }

    .camera-move button {
      background: rgba(148, 163, 184, 0.2);
      color: var(--text);
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: none;
      font-weight: 700;
    }

    .dig-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .event-panel {
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(185, 28, 28, 0.35);
      background: rgba(127, 29, 29, 0.18);
      display: flex;
      flex-direction: column;
      gap: 6px;
      color: #fecdd3;
    }

    .event-panel:not(.active) {
      opacity: 0.7;
      border-color: rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.2);
      color: var(--text-soft);
    }

    .dig-row button {
      font-size: 1rem;
    }

    .stat-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--text-soft);
    }

    .stat-line span.value {
      font-weight: 700;
      color: var(--text);
    }

    .upgrade-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .upgrade-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: rgba(15, 23, 42, 0.95);
      font-size: 0.85rem;
    }

    .upgrade-main {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .upgrade-title {
      font-weight: 600;
    }

    .upgrade-sub {
      color: var(--text-soft);
      font-size: 0.8rem;
    }

    /* LEADERBOARD + DEPTH RULER */

    .leaderboard-card {
      border-radius: 14px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: rgba(15, 23, 42, 0.96);
      padding: 10px 12px;
      font-size: 0.85rem;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.7);
    }

    .leaderboard-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .leaderboard-toggle {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      overflow: hidden;
    }

    .leaderboard-toggle button {
      border-radius: 0;
      box-shadow: none;
      padding: 4px 10px;
      font-size: 0.75rem;
    }

    .leaderboard-toggle button.active {
      background: var(--accent);
      color: #020617;
      border-color: transparent;
    }

    .leaderboard-list {
      max-height: 260px;
      overflow-y: auto;
      padding-right: 4px;
      margin-top: 4px;
    }

    .lb-row {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(31, 41, 55, 0.7);
      align-items: center;
    }

    .lb-row:last-child { border-bottom: none; }

    .lb-row.me {
      background: rgba(56, 189, 248, 0.07);
      border-radius: 8px;
      padding: 4px 6px;
      border: 1px solid rgba(56, 189, 248, 0.2);
    }

    .lb-rank {
      width: 28px;
      text-align: right;
      color: var(--text-soft);
      font-weight: 600;
    }

    .lb-name {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .lb-depth {
      font-weight: 700;
      color: #facc15;
      font-variant-numeric: tabular-nums;
    }

    .me-chip {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.6);
      font-size: 0.7rem;
      color: var(--accent);
    }

    .room-code-pill {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 0.7rem;
      color: #e5e7eb;
      background: rgba(15, 23, 42, 0.9);
    }

    .depth-ruler {
      position: relative;
      width: 80px;
      height: 260px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: linear-gradient(to bottom, #0f172a, #020617 40%, #111827 60%, #0b1220 100%);
      margin-top: 8px;
      overflow: hidden;
    }

    .depth-ruler-track {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 2px;
      transform: translateX(-50%);
      background: linear-gradient(to bottom, #64748b, #020617);
      opacity: 0.7;
    }

    .depth-marker {
      position: absolute;
      left: 12px;
      transform: translateY(50%);
      font-size: 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .depth-marker .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 2px solid #facc15;
      background: #020617;
      box-shadow: 0 0 10px rgba(250, 204, 21, 0.7);
    }

    .depth-marker .label {
      font-size: 0.7rem;
      color: #e5e7eb;
      white-space: nowrap;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.8);
    }

    .depth-marker.me .dot {
      border-color: #38bdf8;
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.9);
    }

    .depth-marker.me .label {
      color: #38bdf8;
    }

    .small-note {
      font-size: 0.72rem;
      color: var(--text-soft);
      margin-top: 4px;
    }

    /* SETUP */

    .setup-grid {
      display: grid;
      grid-template-columns: 1.5fr 1fr;
      gap: 12px;
    }

    @media (max-width: 820px) {
      .setup-grid {
        grid-template-columns: 1fr;
      }
      .col-wide {
        flex-basis: 100%;
      }
    }

    .setup-card {
      border-radius: 14px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: rgba(15, 23, 42, 0.96);
      padding: 12px 14px;
      font-size: 0.9rem;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.7);
    }

    .setup-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    .setup-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .code-badge {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.7);
      font-size: 0.8rem;
      color: #e5e7eb;
    }

    .log {
      margin-top: 10px;
      font-size: 0.76rem;
      color: var(--text-soft);
      max-height: 110px;
      overflow-y: auto;
      border-radius: 10px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.95);
    }

    .log-line { margin-bottom: 2px; }

    @keyframes ripplePulse {
      0% { opacity: 0.35; transform: translate(-50%, -50%) scale(0.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.35); }
    }

    @keyframes panelGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.9; }
    }
  </style>
</head>
<body>
<div class="background-stars"></div>
<div class="app">
  <div class="card-shell">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;">
      <div>
        <h1>
          <span class="icon">‚õèÔ∏è</span>
          <span>DeepMine Online</span>
        </h1>
        <div class="subtitle" id="subtitle">
          Watch your miners dig through layered rock, upgrade drills and tools, and compete on shared rooms or the global board.
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
        <button id="btn-language" class="secondary small" aria-label="Change language">üáπüá∑ / üá¨üáß</button>
        <div id="online-pill" class="pill">
          <div class="pill-dot"></div>
          <span id="online-status-text">Connecting...</span>
        </div>
      </div>
    </div>

    <!-- SETUP -->
    <div id="setup-section" style="margin-top:12px;">
      <div class="setup-grid">
        <div class="setup-card">
          <div class="section-title" id="player-title">Player</div>
          <label for="player-name" id="name-label">Your name</label>
          <input id="player-name" placeholder="Umut, Nova vs." />

          <div class="setup-row">
            <button id="btn-start-solo">
              üåç Solo / Global start
            </button>
          </div>

          <div class="small-note" id="sync-note">
            We will sync online/leaderboards when possible. If offline, the game works
            fully on your device.
          </div>
          <div id="setup-error" class="error"></div>
        </div>

        <div class="setup-card">
          <div class="section-title" id="room-title">Room (optional)</div>
          <label for="room-code-input" id="room-join-label">Join an existing room</label>
          <input id="room-code-input" placeholder="e.g. GOLD01" />

          <div class="setup-row">
            <button id="btn-join-room" class="secondary small">Join room</button>
          </div>

          <div class="setup-row" style="margin-top:10px;">
            <button id="btn-create-room" class="small">
              üè† Create Room
            </button>
            <span id="created-room-code" class="code-badge" style="display:none;"></span>
          </div>

          <div class="small-note" id="room-note">
            Share the room code with friends. With the same code the leaderboard only
            shows players in that room.
          </div>
        </div>
      </div>
    </div>

    <!-- GAME -->
    <div id="game-section" style="display:none; margin-top:16px;">
      <div class="row">
        <!-- LEFT: 3D + controls -->
        <div class="col-wide">
          <div class="mine-panel">
            <canvas id="mine-canvas"></canvas>
            <div class="depth-hud">
              <span>Depth:</span>
              <span class="value" id="depth-label">0 m</span>
            </div>
            <div class="minimap-overlay" aria-hidden="true">
              <div style="display:flex;align-items:center;justify-content:space-between;font-weight:700;font-size:0.76rem;">
                <span>Minimap</span>
                <span id="minimap-depth">0 m</span>
              </div>
              <canvas id="minimap-map" width="150" height="90"></canvas>
            </div>
            <div class="collapse-warning" id="collapse-warning">‚ö†Ô∏è Cave-in! Miners are escaping‚Ä¶</div>
            <div class="floating-container" id="floating-container"></div>
          </div>

          <div id="camera-panel" class="camera-panel">
            <div class="panel-title">üé• Cameras</div>
            <div class="camera-buttons">
              <button data-preset="overview">Overview</button>
              <button data-preset="miner">Miner</button>
              <button data-preset="truck">Truck</button>
              <button data-preset="elevator">Elevator</button>
            </div>
            <div class="camera-move" style="gap:10px;flex-wrap:wrap;">
              <button id="btn-toggle-lock" class="secondary">Lock Camera</button>
              <div class="small-note">1-4 switch views ¬∑ L toggles lock ¬∑ Scroll/drag to orbit</div>
            </div>
          </div>

          <div class="controls-card">
            <div class="dig-row">
              <button id="btn-dig">‚õèÔ∏è Dig!</button>
              <div class="stat-line">
                <span>Per click:</span>
                <span class="value" id="per-click-label">1 m</span>
              </div>
              <div class="stat-line">
                <span id="auto-rate-title">Auto-dig:</span>
                <span class="value" id="auto-rate-label">0 m/s</span>
              </div>
            </div>

            <div class="dig-row" style="margin-top:8px; gap:12px; align-items:flex-start;">
              <button id="btn-charge" class="secondary small">üí• Explosive Charge</button>
              <div class="stat-line">
                <span>Charge power:</span>
                <span class="value" id="charge-status">Ready</span>
              </div>
              <div class="stat-line">
                <span>Bonus multiplier:</span>
                <span class="value" id="charge-mult">x1.0</span>
              </div>
            </div>

            <div class="resource-row">
              <div class="resource-chip">
                üí∞ <span>Cash:</span> <span class="value" id="money-label">0</span>
              </div>
              <div class="resource-chip">
                ü™ô <span>Gold:</span> <span class="value" id="gold-label">0</span>
              </div>
              <div class="resource-chip">
                üõ¢Ô∏è <span>Oil:</span> <span class="value" id="oil-label">0</span>
              </div>
              <div class="resource-chip">
                üíé <span>Gems:</span> <span class="value" id="gems-label">0</span>
              </div>
            </div>

            <div class="section-title" style="margin-top:8px;">Mines</div>
            <div class="mine-tabs" id="mine-tabs"></div>

            <div class="sound-controls">
              <button id="btn-toggle-sfx" class="toggle-btn active">üîä SFX On</button>
              <button id="btn-toggle-music" class="toggle-btn">üéµ Music Off</button>
            </div>

            <div class="event-panel" id="event-panel">
              <div id="event-label">No cave-in, keep digging!</div>
              <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
                <div id="event-timer">‚Äì</div>
                <button id="btn-repair" class="small secondary">Repair (200 üí∞ + 100 üõ¢Ô∏è)</button>
              </div>
            </div>

            <div class="upgrade-list">
              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Upgrade Pickaxe</div>
                  <div class="upgrade-sub">
                    Increase depth per click. Level:
                    <span id="axe-level-label">1</span>
                  </div>
                </div>
                <button id="btn-upgrade-axe" class="small">
                  Upgrade ¬∑ <span id="axe-cost-label">10</span> üí∞
                </button>
              </div>

              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Hire Worker</div>
                  <div class="upgrade-sub">
                    Hire miners that dig automatically. Workers:
                    <span id="miners-label">0</span>
                  </div>
                </div>
                <button id="btn-hire-miner" class="small">
                  Hire ¬∑ <span id="miner-cost-label">25</span> üí∞
                </button>
              </div>

              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Drill Tower</div>
                  <div class="upgrade-sub">
                    Boost auto-dig speed. Level:
                    <span id="drill-level-label">0</span>
                  </div>
                </div>
                <button id="btn-upgrade-drill" class="small">
                  Build ¬∑ <span id="drill-cost-label">100</span> üí∞
                </button>
              </div>

              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Geo Radar</div>
                  <div class="upgrade-sub">
                    Increases chance to find rare ore. Level:
                    <span id="radar-level-label">0</span>
                  </div>
                </div>
                <button id="btn-upgrade-radar" class="small">
                  Upgrade ¬∑ <span id="radar-cost-label">120</span> üí∞
                </button>
              </div>

              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Extraction Efficiency</div>
                  <div class="upgrade-sub">
                    Raises earnings multiplier. Level:
                    <span id="efficiency-level-label">0</span>
                  </div>
                </div>
                <button id="btn-upgrade-efficiency" class="small">
                  Upgrade ¬∑ <span id="efficiency-cost-label">150</span> üí∞
                </button>
              </div>

              <div class="section-title" style="margin-top:10px;">Special Upgrades (Gold & Gems)</div>
              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Endless Elevator</div>
                  <div class="upgrade-sub">+20% auto-dig on every shaft</div>
                </div>
                <button id="btn-upgrade-elevator" class="small">
                  Buy ¬∑ <span id="elevator-cost">300 ü™ô + 20 üíé</span>
                </button>
              </div>
              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Blast Stabilizer</div>
                  <div class="upgrade-sub">Reduces cave-in penalty</div>
                </div>
                <button id="btn-upgrade-stabilizer" class="small">
                  Buy ¬∑ <span id="stabilizer-cost">250 ü™ô + 10 üíé</span>
                </button>
              </div>
              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Crystal Intelligence</div>
                  <div class="upgrade-sub">+30% chance to discover gems</div>
                </div>
                <button id="btn-upgrade-crystallab" class="small">
                  Buy ¬∑ <span id="crystallab-cost">500 ü™ô + 35 üíé</span>
                </button>
              </div>
              <div class="upgrade-row">
                <div class="upgrade-main">
                  <div class="upgrade-title">Luxury Gear</div>
                  <div class="upgrade-sub">Each level +5% click power</div>
                </div>
                <button id="btn-upgrade-luxury" class="small">
                  Buy ¬∑ <span id="luxury-cost">100 ü™ô + 5 üíé</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- RIGHT: leaderboard + depth ruler + log -->
        <div class="col">
          <div class="leaderboard-card">
            <div class="leaderboard-header">
              <div>
                <div class="section-title">Leaderboard</div>
                <div id="room-label" class="small-note">Global leaderboard</div>
              </div>
              <div class="leaderboard-toggle">
                <button id="btn-view-global" class="small active">üåç Global</button>
                <button id="btn-view-room" class="small">üè† Room</button>
              </div>
            </div>

            <div class="leaderboard-list" id="leaderboard-list"></div>
            <button id="btn-refresh-leaderboard" class="small secondary" style="margin-top:6px;">
              ‚Üª Yenile
            </button>

            <div class="small-note" style="margin-top:4px;">
              Online data is synced via Supabase. If offline,
              progress stays on this device.
            </div>

            <div class="section-title" style="margin-top:10px;">Depth Map</div>
            <div class="depth-ruler" id="depth-ruler">
              <div class="depth-ruler-track"></div>
            </div>
          </div>

          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.164.1/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js?module";
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  // ===================== Supabase =====================
  const SUPABASE_URL = "https://tkggowekxmnlixwinszl.supabase.co";
  const SUPABASE_ANON_KEY =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrZ2dvd2VreG1ubGl4d2luc3psIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3MzI1NjcsImV4cCI6MjA4MDMwODU2N30.y1GSvarl9YyBqMaP8x6SXeD88EJ10gjee4rlr6oLyZg";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const LS_KEY = "deepmine_state_v1";

  // ===================== State =====================
  const MINE_PRESETS = [
    { id: "main", name: "Main Shaft", goldBonus: 1, oilBonus: 1, gemBonus: 1, collapseRisk: 0.0 },
    { id: "deep_gold", name: "Golden Vein", goldBonus: 1.8, oilBonus: 0.7, gemBonus: 1.2, collapseRisk: 0.03 },
    { id: "oil_field", name: "Oil Field", goldBonus: 0.6, oilBonus: 2.0, gemBonus: 1.0, collapseRisk: 0.04 },
    { id: "crystal_cave", name: "Crystal Cavern", goldBonus: 0.9, oilBonus: 0.8, gemBonus: 2.2, collapseRisk: 0.06 },
  ];

  const defaultState = {
    playerName: "",
    playerId: null,
    roomCode: null,
    currentMineId: "main",
    mines: {
      main: {
        id: "main",
        name: "Main Shaft",
        depth: 0,
        axeLevel: 1,
        miners: 0,
        drillLevel: 0,
        radarLevel: 0,
        efficiencyLevel: 0,
      },
    },
    language: "en",
    gold: 0,
    oil: 0,
    gems: 0,
    money: 0,
    logistics: {
      elevatorLevel: 1,
      truckLevel: 1,
      elevatorSpeedBase: 1,
      truckSpeedBase: 1,
      elevatorCapacityBase: 50,
      truckCapacityBase: 200,
    },
    oreFlow: {
      shaftOre: 0,
      elevatorLoad: 0,
      surfaceOre: 0,
      truckLoad: 0,
    },
    chargeReadyAt: 0,
    chargeActiveUntil: 0,
    soundEnabled: true,
    musicEnabled: false,
    perClick: 1,
    autoRate: 0,
    bestDepthSynced: 0,
    specialUpgrades: {
      elevator: false,
      stabilizer: 0,
      crystalLab: false,
      luxury: 0,
    },
    stabilityBuffUntil: 0,
    currentEvent: {
      type: null,
      endsAt: 0,
      penaltyApplied: false,
      mineId: null,
    },
  };

  let state = { ...defaultState, specialUpgrades: { ...defaultState.specialUpgrades }, currentEvent: { ...defaultState.currentEvent } };
  let sessionStarted = false;
  let leaderboardMode = "global"; // "global" | "room"
  let supabaseOnline = true;
  let lastSyncError = null;
  let prevChargeActive = false;
  let userInteracted = false;

  function getMinePreset(id) {
    return MINE_PRESETS.find((m) => m.id === id) || MINE_PRESETS[0];
  }

  function getCurrentMine() {
    return state.mines[state.currentMineId];
  }

  function updateCurrentMine(updater) {
    const mine = getCurrentMine();
    if (!mine) return;
    updater(mine);
  }

  function bestDepthAcrossMines() {
    return Math.max(0, ...Object.values(state.mines || {}).map((m) => m.depth || 0));
  }

  function markInteraction() {
    if (userInteracted) return;
    userInteracted = true;
    soundManager.ensureUnlocked();
    soundManager.updateMusicState();
  }

  // cost helpers (simple exponential-ish)
  function axeCost(level) {
    return Math.round(12 * Math.pow(1.95, level - 1));
  }
  function minerCost(count) {
    return Math.round(30 * Math.pow(1.75, count));
  }
  function drillCost(level) {
    return Math.round(120 * Math.pow(2.35, level));
  }
  function radarCost(level) {
    return Math.round(150 * Math.pow(1.85, level));
  }
  function efficiencyCost(level) {
    return Math.round(200 * Math.pow(1.75, level));
  }

  // ===================== DOM refs =====================
  const setupSection = document.getElementById("setup-section");
  const gameSection = document.getElementById("game-section");
  const setupErrorEl = document.getElementById("setup-error");
  const playerNameInput = document.getElementById("player-name");
  const roomCodeInput = document.getElementById("room-code-input");
  const createdRoomCodeEl = document.getElementById("created-room-code");

  const depthLabel = document.getElementById("depth-label");
  const minimapDepthLabel = document.getElementById("minimap-depth");
  const minimapCanvas = document.getElementById("minimap-map");
  const subtitleEl = document.getElementById("subtitle");
  const playerTitleEl = document.getElementById("player-title");
  const nameLabelEl = document.getElementById("name-label");
  const syncNoteEl = document.getElementById("sync-note");
  const roomTitleEl = document.getElementById("room-title");
  const roomJoinLabelEl = document.getElementById("room-join-label");
  const roomNoteEl = document.getElementById("room-note");
  const autoRateTitle = document.getElementById("auto-rate-title");
  const moneyLabel = document.getElementById("money-label");
  const goldLabel = document.getElementById("gold-label");
  const oilLabel = document.getElementById("oil-label");
  const gemsLabel = document.getElementById("gems-label");
  const perClickLabel = document.getElementById("per-click-label");
  const autoRateLabel = document.getElementById("auto-rate-label");
  const axeLevelLabel = document.getElementById("axe-level-label");
  const minersLabel = document.getElementById("miners-label");
  const drillLevelLabel = document.getElementById("drill-level-label");
  const radarLevelLabel = document.getElementById("radar-level-label");
  const efficiencyLevelLabel = document.getElementById("efficiency-level-label");
  const axeCostLabel = document.getElementById("axe-cost-label");
  const minerCostLabel = document.getElementById("miner-cost-label");
  const drillCostLabel = document.getElementById("drill-cost-label");
  const radarCostLabel = document.getElementById("radar-cost-label");
  const efficiencyCostLabel = document.getElementById("efficiency-cost-label");
  const logEl = document.getElementById("log");
  const floatingContainer = document.getElementById("floating-container");
  const chargeStatusEl = document.getElementById("charge-status");
  const chargeMultEl = document.getElementById("charge-mult");

  const onlinePill = document.getElementById("online-pill");
  const onlineStatusText = document.getElementById("online-status-text");
  const roomLabel = document.getElementById("room-label");

  const leaderboardListEl = document.getElementById("leaderboard-list");
  const depthRulerEl = document.getElementById("depth-ruler");
  const mineTabsEl = document.getElementById("mine-tabs");
  const collapseWarningEl = document.getElementById("collapse-warning");
  const eventPanel = document.getElementById("event-panel");
  const eventLabel = document.getElementById("event-label");
  const eventTimer = document.getElementById("event-timer");
  const btnRepair = document.getElementById("btn-repair");

  const btnUpgradeElevator = document.getElementById("btn-upgrade-elevator");
  const btnUpgradeStabilizer = document.getElementById("btn-upgrade-stabilizer");
  const btnUpgradeCrystalLab = document.getElementById("btn-upgrade-crystallab");
  const btnUpgradeLuxury = document.getElementById("btn-upgrade-luxury");
  const elevatorCostLabel = document.getElementById("elevator-cost");
  const stabilizerCostLabel = document.getElementById("stabilizer-cost");
  const crystalLabCostLabel = document.getElementById("crystallab-cost");
  const luxuryCostLabel = document.getElementById("luxury-cost");

  const btnStartSolo = document.getElementById("btn-start-solo");
  const btnJoinRoom = document.getElementById("btn-join-room");
  const btnCreateRoom = document.getElementById("btn-create-room");
  const btnDig = document.getElementById("btn-dig");
  const btnUpgradeAxe = document.getElementById("btn-upgrade-axe");
  const btnHireMiner = document.getElementById("btn-hire-miner");
  const btnUpgradeDrill = document.getElementById("btn-upgrade-drill");
  const btnUpgradeRadar = document.getElementById("btn-upgrade-radar");
  const btnUpgradeEfficiency = document.getElementById("btn-upgrade-efficiency");
  const btnToggleSfx = document.getElementById("btn-toggle-sfx");
  const btnToggleMusic = document.getElementById("btn-toggle-music");
  const btnLanguage = document.getElementById("btn-language");
  const btnCharge = document.getElementById("btn-charge");
  const btnViewGlobal = document.getElementById("btn-view-global");
  const btnViewRoom = document.getElementById("btn-view-room");
  const btnRefreshLeaderboard = document.getElementById("btn-refresh-leaderboard");
  const cameraButtons = document.querySelectorAll('#camera-panel button[data-preset]');
  const btnToggleLock = document.getElementById("btn-toggle-lock");

  const translations = {
    en: {
      subtitle:
        "Watch your miners dig through layered rock, upgrade drills and tools, and compete on shared rooms or the global board.",
      playerTitle: "Player",
      nameLabel: "Your name",
      namePlaceholder: "Umut, Nova etc.",
      startSolo: "üåç Solo / Global start",
      syncNote: "We will sync online/leaderboards when possible. If offline, the game works fully on your device.",
      roomTitle: "Room (optional)",
      roomJoinLabel: "Join an existing room",
      roomPlaceholder: "e.g. GOLD01",
      joinRoom: "Join room",
      createRoom: "üè† Create Room",
      roomNote: "Share the room code with friends. With the same code the leaderboard only shows players in that room.",
      collapseWarning: "‚ö†Ô∏è Cave-in! Miners are escaping‚Ä¶",
      noCollapse: "No cave-in, keep digging!",
      repair: "Repair (200 üí∞ + 100 üõ¢Ô∏è)",
      autoRateLabel: "Auto-dig:",
      sfxOn: "üîä SFX On",
      sfxOff: "üîà SFX Off",
      musicOn: "üéµ Music On",
      musicOff: "üéµ Music Off",
      onlineConnecting: "Connecting...",
      onlineOffline: "Offline ¬∑ saving only on this device",
      onlineOnline: "Online ¬∑ syncing leaderboard",
    },
    tr: {
      subtitle:
        "Madencilerini katmanlƒ± kayalarda izle, ekipmanƒ±nƒ± geli≈ütir ve global ya da arkada≈ü odalarƒ±nda yarƒ±≈ü.",
      playerTitle: "Oyuncu",
      nameLabel: "ƒ∞smin",
      namePlaceholder: "Umut, Nova vs.",
      startSolo: "üåç Tek ba≈üƒ±ma / Global",
      syncNote: "M√ºmk√ºn olduƒüunda √ßevrim i√ßi senkronize ederiz. Offline ise her ≈üey cihazƒ±nda √ßalƒ±≈üƒ±r.",
      roomTitle: "Oda (isteƒüe baƒülƒ±)",
      roomJoinLabel: "Mevcut bir odaya katƒ±l",
      roomPlaceholder: "√ñrn: GOLD01",
      joinRoom: "Odaya Katƒ±l",
      createRoom: "üè† Yeni Oda",
      roomNote: "Oda kodunu arkada≈ülarƒ±nla payla≈ü. Aynƒ± kodla girerlerse leaderboard sadece onlarƒ± g√∂sterir.",
      collapseWarning: "‚ö†Ô∏è G√∂√ß√ºk! ƒ∞≈ü√ßiler ka√ßmaya √ßalƒ±≈üƒ±yor‚Ä¶",
      noCollapse: "G√∂√ß√ºk yok, kazmaya devam!",
      repair: "Onar (200 üí∞ + 100 üõ¢Ô∏è)",
      autoRateLabel: "Oto kazma:",
      sfxOn: "üîä Ses A√ßƒ±k",
      sfxOff: "üîà Ses Kapalƒ±",
      musicOn: "üéµ M√ºzik A√ßƒ±k",
      musicOff: "üéµ M√ºzik Kapalƒ±",
      onlineConnecting: "Online baƒülanmaya √ßalƒ±≈üƒ±lƒ±yor...",
      onlineOffline: "Offline ¬∑ kayƒ±t sadece bu cihazda",
      onlineOnline: "Online ¬∑ leaderboard senkronize ediliyor",
    },
  };

  function t(key) {
    const lang = state.language || "en";
    return translations[lang]?.[key] ?? translations.en[key] ?? key;
  }

  function applyLanguage() {
    const lang = state.language || "en";
    document.documentElement.lang = lang;
    if (subtitleEl) subtitleEl.textContent = t("subtitle");
    if (playerTitleEl) playerTitleEl.textContent = t("playerTitle");
    if (nameLabelEl) nameLabelEl.textContent = t("nameLabel");
    if (playerNameInput) playerNameInput.placeholder = t("namePlaceholder");
    if (btnStartSolo) btnStartSolo.textContent = t("startSolo");
    if (syncNoteEl) syncNoteEl.textContent = t("syncNote");
    if (roomTitleEl) roomTitleEl.textContent = t("roomTitle");
    if (roomJoinLabelEl) roomJoinLabelEl.textContent = t("roomJoinLabel");
    if (roomCodeInput) roomCodeInput.placeholder = t("roomPlaceholder");
    if (btnJoinRoom) btnJoinRoom.textContent = t("joinRoom");
    if (btnCreateRoom) btnCreateRoom.textContent = t("createRoom");
    if (roomNoteEl) roomNoteEl.textContent = t("roomNote");
    if (btnRepair) btnRepair.textContent = t("repair");
    if (onlineStatusText) onlineStatusText.textContent = t("onlineConnecting");
    if (btnLanguage) btnLanguage.textContent = state.language === "en" ? "üá¨üáß EN" : "üáπüá∑ TR";
    if (autoRateTitle) autoRateTitle.textContent = t("autoRateLabel");
    if (collapseWarningEl) collapseWarningEl.textContent = t("collapseWarning");
  }


  function log(msg) {
    const line = document.createElement("div");
    line.className = "log-line";
    const time = new Date().toLocaleTimeString();
    line.textContent = `[${time}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  class SoundManager {
    constructor() {
      this.unlocked = false;
      this.masterVolume = 0.4;
      this.cooldowns = {
        dig: 0,
        gem: 0,
        levelUp: 0,
        collapse: 0,
        upgrade: 0,
        money: 0,
      };
      this.sounds = {
        dig: this.createSound("sounds/dig.mp3", false, 0.75),
        upgrade: this.createSound("sounds/upgrade.wav", false, 0.7),
        cash: this.createSound("sounds/cash.mp3", false, 0.6),
        gem: this.createSound("sounds/gem.wav", false, 0.55),
        collapse: this.createSound("sounds/upgrade.wav", false, 0.8),
        music: this.createSound("sounds/bg-music.mp3", true, 0.25),
      };
    }

    createSound(src, loop = false, volume = 0.8) {
      try {
        const a = new Audio(src);
        a.loop = loop;
        a.volume = volume;
        return a;
      } catch (e) {
        console.warn("Sound could not load", src, e);
        return null;
      }
    }

    ensureUnlocked() {
      if (this.unlocked) return;
      this.unlocked = true;
    }

    update(dt) {
      Object.keys(this.cooldowns).forEach((k) => {
        this.cooldowns[k] = Math.max(0, this.cooldowns[k] - dt);
      });
    }

    play(name, minInterval = 0.3, volume = 1.0) {
      if (!state.soundEnabled || !userInteracted) return;
      const s = this.sounds[name];
      if (!s) return;
      if (this.cooldowns[name] > 0) return;
      this.ensureUnlocked();
      this.cooldowns[name] = minInterval;
      try {
        s.currentTime = 0;
        s.volume = this.masterVolume * volume;
        s.play();
      } catch (e) {
        /* ignore */
      }
    }

    playDig() {
      this.play("dig", 0.08, 0.9);
    }

    playUpgrade() {
      this.play("upgrade", 0.5, 0.9);
    }

    playMoney() {
      this.play("cash", 0.3, 0.8);
    }

    playGem() {
      this.play("gem", 0.2, 0.7);
    }

    playLevelUp() {
      this.play("upgrade", 1.0, 1.0);
    }

    playCollapse() {
      this.play("collapse", 0.6, 1.0);
    }

    updateMusicState() {
      const m = this.sounds.music;
      if (!m) return;
      if (state.musicEnabled && state.soundEnabled && userInteracted) {
        this.ensureUnlocked();
        m.volume = this.masterVolume * 0.6;
        m.play().catch(() => {});
      } else {
        m.pause();
      }
    }

    toggleMute() {
      state.soundEnabled = !state.soundEnabled;
      if (!state.soundEnabled && this.sounds.music) this.sounds.music.pause();
      this.updateMusicState();
      saveLocalState();
      updateStatsUI();
    }

    toggleMusic() {
      state.musicEnabled = !state.musicEnabled;
      this.updateMusicState();
      saveLocalState();
      updateStatsUI();
    }
  }

  const soundManager = new SoundManager();

  // ===================== Local Storage =====================
  function loadLocalState() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const saved = JSON.parse(raw);
      state = { ...defaultState, ...saved };

      // migrate old flat fields
      if (!state.mines) {
        state.mines = {
          main: {
            id: "main",
            name: "Ana Maden",
            depth: saved.depth || 0,
            axeLevel: saved.axeLevel || 1,
            miners: saved.miners || 0,
            drillLevel: saved.drillLevel || 0,
            radarLevel: saved.radarLevel || 0,
            efficiencyLevel: saved.efficiencyLevel || 0,
          },
        };
        state.currentMineId = "main";
      }
      // merge missing defaults inside mines
      Object.values(state.mines).forEach((mine) => {
        mine.axeLevel ??= 1;
        mine.miners ??= 0;
        mine.drillLevel ??= 0;
        mine.radarLevel ??= 0;
        mine.efficiencyLevel ??= 0;
        mine.depth ??= 0;
        mine.name ??= getMinePreset(mine.id)?.name || "Mine";
      });

      state.specialUpgrades = { ...defaultState.specialUpgrades, ...(state.specialUpgrades || {}) };
      state.logistics = { ...defaultState.logistics, ...(state.logistics || {}) };
      state.oreFlow = { ...defaultState.oreFlow, ...(state.oreFlow || {}) };
      state.currentEvent = { ...defaultState.currentEvent, ...(state.currentEvent || {}) };
      state.stabilityBuffUntil = state.stabilityBuffUntil || 0;
      state.language = state.language || "en";
    } catch (e) {
      console.error("Failed to load state", e);
    }
  }

  function saveLocalState() {
    try {
      localStorage.setItem(LS_KEY, JSON.stringify(state));
    } catch (e) {
      console.error("Failed to save state", e);
    }
  }

  function isCollapseActive() {
    return (
      state.currentEvent &&
      state.currentEvent.type === "collapse" &&
      state.currentEvent.mineId === state.currentMineId &&
      Date.now() < state.currentEvent.endsAt
    );
  }

  function updateEventUI() {
    if (!eventPanel) return;
    if (isCollapseActive()) {
      eventPanel.classList.add("active");
      const remaining = Math.max(0, state.currentEvent.endsAt - Date.now());
      eventLabel.textContent = t("collapseWarning");
      eventTimer.textContent = `${(remaining / 1000).toFixed(1)} s`;
      collapseWarningEl.classList.add("active");
    } else {
      collapseWarningEl.classList.remove("active");
      eventLabel.textContent = t("noCollapse");
      eventTimer.textContent = "‚Äì";
      eventPanel.classList.remove("active");
    }
  }

  function renderMineTabs() {
    if (!mineTabsEl) return;
    mineTabsEl.innerHTML = "";
    Object.values(state.mines).forEach((mine) => {
      const btn = document.createElement("button");
      btn.className = "mine-tab";
      if (mine.id === state.currentMineId) btn.classList.add("active");
      btn.textContent = mine.name;
      btn.addEventListener("click", () => {
        state.currentMineId = mine.id;
        recalcDerivedStats();
        rebuildMinersForCurrentMine();
        updateStatsUI();
        renderMineTabs();
        log(`${mine.name} selected.`);
        saveLocalState();
      });
      mineTabsEl.appendChild(btn);
    });

    const nextPreset = MINE_PRESETS.find((p) => !state.mines[p.id]);
    if (nextPreset) {
      const addBtn = document.createElement("button");
      addBtn.className = "mine-tab add";
      addBtn.textContent = "+ Open New Shaft";
      addBtn.addEventListener("click", () => {
        unlockNextMine();
      });
      mineTabsEl.appendChild(addBtn);
    }
  }

  function unlockNextMine() {
    const unlockedExtras = Math.max(0, Object.keys(state.mines).length - 1);
    const cost = unlockedExtras === 0 ? { money: 500, gold: 200 } : { money: 2000, oil: 400, gems: 40 };
    if (state.money < (cost.money || 0) || state.gold < (cost.gold || 0) || state.oil < (cost.oil || 0) || state.gems < (cost.gems || 0)) {
      log("Not enough resources for a new shaft.");
      return;
    }
    const preset = MINE_PRESETS.find((p) => !state.mines[p.id]);
    if (!preset) return;
    state.money -= cost.money || 0;
    state.gold -= cost.gold || 0;
    state.oil -= cost.oil || 0;
    state.gems -= cost.gems || 0;

    state.mines[preset.id] = {
      id: preset.id,
      name: preset.name,
      depth: 0,
      axeLevel: 1,
      miners: 0,
      drillLevel: 0,
      radarLevel: 0,
      efficiencyLevel: 0,
    };
    state.currentMineId = preset.id;
    recalcDerivedStats();
    rebuildMinersForCurrentMine();
    renderMineTabs();
    updateStatsUI();
    log(`New mine opened: ${preset.name}`);
    soundManager.playUpgrade();
    saveLocalState();
  }

  function triggerCollapse() {
    const mine = getCurrentMine();
    if (!mine) return;
    state.currentEvent = {
      type: "collapse",
      endsAt: Date.now() + 25000,
      penaltyApplied: false,
      mineId: mine.id,
    };
    shakeStrength = 1.5;
    shakeTime = 1.2;
    log(`‚ö†Ô∏è Cave-in! ${mine.name} collapsed, workers are fleeing.`);
    soundManager.playUpgrade();
    updateEventUI();
  }

  function resolveCollapse(paid = false) {
    if (!state.currentEvent || state.currentEvent.type !== "collapse") return;
    if (paid) {
      state.stabilityBuffUntil = Date.now() + 60000;
      log("Repairs complete, temporary stability bonus active!");
    } else {
      log("Cave-in ended, back to digging!");
    }
    state.currentEvent = { ...defaultState.currentEvent };
    recalcDerivedStats();
    updateEventUI();
    soundManager.playUpgrade();
    saveLocalState();
  }

  function maybeTriggerCollapse(dt) {
    const mine = getCurrentMine();
    if (!mine || isCollapseActive()) return;
    if (mine.depth < 160) return;
    const preset = getMinePreset(mine.id);
    const stabilizerCut = state.specialUpgrades.stabilizer ? 0.6 : 1;
    const risk = (preset.collapseRisk || 0.01) * (1 + mine.depth / 600) * stabilizerCut;
    const chance = risk * dt;
    if (Math.random() < chance) {
      triggerCollapse();
    }
  }

  // ===================== Online status UI =====================
  function updateOnlineStatusUI() {
    if (!onlinePill) return;
    if (supabaseOnline) {
      onlinePill.classList.remove("offline");
      onlineStatusText.textContent = t("onlineOnline");
    } else {
      onlinePill.classList.add("offline");
      onlineStatusText.textContent = t("onlineOffline");
    }
  }

  // ===================== Mining logic =====================
  function isChargeActive() {
    return Date.now() < state.chargeActiveUntil;
  }

  function nextChargeReadyInMs() {
    return Math.max(0, state.chargeReadyAt - Date.now());
  }

  function chargeMultiplier() {
    const mine = getCurrentMine();
    if (!mine) return 1;
    return 2 + mine.drillLevel * 0.15 + mine.radarLevel * 0.05;
  }

  function recalcDerivedStats() {
    const mine = getCurrentMine();
    if (!mine) return;
    const luxuryBoost = 1 + (state.specialUpgrades.luxury || 0) * 0.05;
    const efficiencyBoost = 1 + mine.efficiencyLevel * 0.07;
    const basePerClick = (1 + (mine.axeLevel - 1) * 0.65) * luxuryBoost;
    const activeChargeBoost = isChargeActive() ? chargeMultiplier() : 1;
    state.perClick = basePerClick * efficiencyBoost * activeChargeBoost;
    let autoBase = mine.miners * 0.32 + mine.drillLevel * 1.4;
    autoBase *= 1 + mine.efficiencyLevel * 0.05;
    if (state.specialUpgrades.elevator) autoBase *= 1.2;
    if (Date.now() < state.stabilityBuffUntil) autoBase *= 1.1;
    state.autoRate = isCollapseActive() ? 0 : autoBase;
  }

  function miningBoostMultiplier() {
    return minerBoostTimer > 0 ? 2 : 1;
  }

  function updateBoostTimers(dt) {
    if (minerBoostTimer > 0) {
      minerBoostTimer = Math.max(0, minerBoostTimer - dt);
    }
    if (truckBoostTimer > 0) {
      truckBoostTimer = Math.max(0, truckBoostTimer - dt);
    }
  }

  function applyMining(amount, isAuto = false) {
    const mine = getCurrentMine();
    if (!mine || amount <= 0)
      return { moneyGain: 0, goldGain: 0, oilGain: 0, gemGain: 0 };

    mine.depth += amount;
    if (mine.depth < 0) mine.depth = 0;

    const preset = getMinePreset(mine.id);
    const base = amount;
    const depthFactor = 1 + mine.depth * 0.00055;
    const goldGain = base * (0.25 + Math.random() * 0.28) * depthFactor * preset.goldBonus;
    const oilGain = base * (0.16 + Math.random() * 0.25) * (1 + mine.radarLevel * 0.05) * preset.oilBonus;
    const crystalBoost = state.specialUpgrades.crystalLab ? 0.3 : 0;
    const gemChance = 0.02 + mine.radarLevel * 0.01 + crystalBoost + Math.min(0.18, mine.depth / 3800);
    const gemGain = Math.random() < gemChance ? base * (1.4 + Math.random() * (1 + mine.radarLevel * 0.35)) * preset.gemBonus : 0;

    state.gold += goldGain;
    state.oil += oilGain;
    state.gems += gemGain;

    const moneyGainRaw = goldGain * 1 + oilGain * 1.45 + gemGain * 6.5;
    const oreValue = moneyGainRaw * (1 + mine.efficiencyLevel * 0.12);
    state.oreFlow.shaftOre += oreValue;

    if (!isAuto) {
      log(`+${oreValue.toFixed(1)} ore added to shaft ¬∑ Depth: ${mine.depth.toFixed(1)} m`);
    }

    return { moneyGain: 0, oreValue, goldGain, oilGain, gemGain };
  }

  function canAfford(cost) {
    return state.money >= cost;
  }

  function spend(cost) {
    if (!canAfford(cost)) return false;
    state.money -= cost;
    return true;
  }

  function updateStatsUI() {
    const mine = getCurrentMine();
    if (!mine) return;
    depthLabel.textContent = `${mine.depth.toFixed(1)} m`;
    moneyLabel.textContent = state.money.toFixed(1);
    goldLabel.textContent = state.gold.toFixed(1);
    oilLabel.textContent = state.oil.toFixed(1);
    gemsLabel.textContent = state.gems.toFixed(1);
    perClickLabel.textContent = `${state.perClick.toFixed(1)} m`;
    autoRateLabel.textContent = `${state.autoRate.toFixed(2)} m/s`;
    if (minimapDepthLabel) minimapDepthLabel.textContent = `${mine.depth.toFixed(0)} m`;
    axeLevelLabel.textContent = mine.axeLevel;
    minersLabel.textContent = mine.miners;
    drillLevelLabel.textContent = mine.drillLevel;
    radarLevelLabel.textContent = mine.radarLevel;
    efficiencyLevelLabel.textContent = mine.efficiencyLevel;
    axeCostLabel.textContent = axeCost(mine.axeLevel).toFixed(0);
    minerCostLabel.textContent = minerCost(mine.miners).toFixed(0);
    drillCostLabel.textContent = drillCost(mine.drillLevel).toFixed(0);
    radarCostLabel.textContent = radarCost(mine.radarLevel).toFixed(0);
    efficiencyCostLabel.textContent = efficiencyCost(mine.efficiencyLevel).toFixed(0);

    elevatorCostLabel.textContent = "300 ü™ô + 20 üíé";
    stabilizerCostLabel.textContent = "250 ü™ô + 10 üíé";
    crystalLabCostLabel.textContent = "500 ü™ô + 35 üíé";
    luxuryCostLabel.textContent = `100 ü™ô + 5 üíé (Lv.${state.specialUpgrades.luxury || 0})`;

    const readyIn = nextChargeReadyInMs();
    if (isChargeActive()) {
      chargeStatusEl.textContent = "ACTIVE";
      chargeStatusEl.style.color = "#facc15";
    } else if (readyIn <= 0) {
      chargeStatusEl.textContent = "Ready";
      chargeStatusEl.style.color = "#22c55e";
    } else {
      chargeStatusEl.textContent = `${(readyIn / 1000).toFixed(1)} s`;
      chargeStatusEl.style.color = "#f97373";
    }
    chargeMultEl.textContent = `x${chargeMultiplier().toFixed(1)}`;

    btnCharge.disabled = readyIn > 0 && !isChargeActive();
    btnCharge.classList.toggle("active", isChargeActive());

    btnToggleSfx.classList.toggle("active", state.soundEnabled);
    btnToggleSfx.textContent = state.soundEnabled ? t("sfxOn") : t("sfxOff");
    btnToggleMusic.classList.toggle("active", state.musicEnabled);
    btnToggleMusic.textContent = state.musicEnabled ? t("musicOn") : t("musicOff");

    // room label
    if (state.roomCode) {
      roomLabel.textContent = `Room: ${state.roomCode}`;
    } else {
      roomLabel.textContent = "Global leaderboard";
    }

    const collapse = isCollapseActive();
    btnDig.disabled = collapse;
    btnUpgradeAxe.disabled = !canAfford(axeCost(mine.axeLevel));
    btnHireMiner.disabled = !canAfford(minerCost(mine.miners));
    btnUpgradeDrill.disabled = !canAfford(drillCost(mine.drillLevel));
    btnUpgradeRadar.disabled = !canAfford(radarCost(mine.radarLevel));
    btnUpgradeEfficiency.disabled = !canAfford(efficiencyCost(mine.efficiencyLevel));

    btnUpgradeElevator.disabled = state.specialUpgrades.elevator || state.gold < 300 || state.gems < 20;
    btnUpgradeStabilizer.disabled = state.specialUpgrades.stabilizer >= 1 || state.gold < 250 || state.gems < 10;
    btnUpgradeCrystalLab.disabled = state.specialUpgrades.crystalLab || state.gold < 500 || state.gems < 35;
    btnUpgradeLuxury.disabled = state.gold < 100 || state.gems < 5;

    updateEventUI();
    renderMinimap();
  }

  function renderMinimap() {
    if (!minimapCanvas) return;
    const ctx = minimapCanvas.getContext("2d");
    const w = minimapCanvas.width;
    const h = minimapCanvas.height;
    ctx.clearRect(0, 0, w, h);

    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, "#0ea5e9");
    grad.addColorStop(1, "#0f172a");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    ctx.strokeStyle = "rgba(148, 163, 184, 0.35)";
    ctx.lineWidth = 1;
    for (let y = 0; y <= h; y += 18) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }

    const mines = Object.values(state.mines || {});
    const maxDepth = Math.max(80, ...mines.map((m) => m.depth || 0));
    mines.forEach((m, idx) => {
      const ratio = mines.length <= 1 ? 0.5 : idx / (mines.length - 1);
      const x = 20 + ratio * (w - 40);
      const y = Math.min(h - 10, ((m.depth || 0) / maxDepth) * (h - 12));
      ctx.strokeStyle = "rgba(56, 189, 248, 0.55)";
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.fillStyle = m.id === state.currentMineId ? "#38bdf8" : "#f59e0b";
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(226, 232, 240, 0.7)";
      ctx.font = "10px Inter, sans-serif";
      ctx.fillText(m.name || "Mine", x - 12, Math.min(h - 4, y + 12));
    });
  }

  // ===================== Three.js =====================
  let scene, camera, minimapCamera, renderer, cameraRig, controls;
  let shaftGroup, drillMesh, minerGroup, minerArmL, minerArmR, pickaxeMesh;
  let miner, truck, elevatorAnchor;
  let minerAnchor, truckAnchor, overviewAnchor;

  const cameraState = {
    mode: "overview",
    target: new THREE.Vector3(),
    desiredPosition: new THREE.Vector3(),
    currentTarget: new THREE.Vector3(),
    lockToAction: true,
  };
  let oreDecorations = [];
  let dustParticles = [];
  let minimapMarker;
  let supportBeams = [];
  let lanterns = [];
  let cartMesh;
  let cartWheels = [];
  let cartDirection = 1;
  let cartOffset = 0;
  let lastFrameTime = performance.now();
  let digPulse = 0;
  let shakeTime = 0;
  let shakeStrength = 0;
  let minerDigTimer = 0;
  let autoDigTimer = 0;
  let autoSoundTimer = 0;
  let depthTargetY = 0;
  let minerBoostTimer = 0;
  let truckBoostTimer = 0;
  const tempVec = new THREE.Vector3();
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const elevatorState = {
    mode: "idle_surface",
    progress: 0,
  };
  const truckState = {
    hasLoad: false,
  };
  let minerClones = [];

  const dustMaterial = new THREE.MeshStandardMaterial({
    color: 0xc4b5a1,
    roughness: 0.9,
    metalness: 0.05,
  });

  function createStrataTexture() {
    const size = 256;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext("2d");

    let y = 0;
    while (y < size) {
      const h = 10 + Math.random() * 25;
      const depthRatio = y / size;
      const light = 14 + Math.random() * 20 - depthRatio * 8;
      ctx.fillStyle = `hsl(28, 25%, ${Math.max(8, light)}%)`;
      ctx.fillRect(0, y, size, h);
      y += h;
    }

    const grad = ctx.createLinearGradient(0, 0, 0, size);
    grad.addColorStop(0.35, "rgba(0,0,0,0)");
    grad.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1, 8);
    tex.anisotropy = 4;
    return tex;
  }

  function createSupportBeams() {
    supportBeams.forEach((b) => shaftGroup.remove(b));
    supportBeams = [];
    const beamMat = new THREE.MeshStandardMaterial({ color: 0x4b5563, roughness: 0.78, metalness: 0.08 });
    for (let i = 0; i < 14; i++) {
      const frame = new THREE.Group();
      const crossTop = new THREE.Mesh(new THREE.BoxGeometry(5.6, 0.2, 0.3), beamMat);
      const crossBottom = crossTop.clone();
      crossBottom.position.y = -1.2;
      const sideA = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1.5, 0.3), beamMat);
      sideA.position.set(-2.6, -0.6, 0);
      const sideB = sideA.clone();
      sideB.position.x = 2.6;
      frame.add(crossTop, crossBottom, sideA, sideB);
      frame.position.y = -i * 6 - 1.6;
      frame.rotation.y = (i % 2 === 0 ? 0 : Math.PI / 36);
      shaftGroup.add(frame);
      supportBeams.push(frame);
    }
  }

  function addLantern(position) {
    const lantern = new THREE.Group();
    const cage = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.4, 8), new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 0.7, roughness: 0.25 }));
    cage.rotation.x = Math.PI;
    cage.position.y = -0.2;
    const light = new THREE.PointLight(0xf59e0b, 1.35, 9, 2);
    light.position.set(0, -0.4, 0);
    lantern.add(cage, light);
    lantern.position.copy(position);
    shaftGroup.add(lantern);
    lanterns.push({ light, mesh: lantern, phase: Math.random() * Math.PI * 2 });
  }

  function createLanterns() {
    lanterns.forEach((lan) => shaftGroup.remove(lan.mesh));
    lanterns = [];
    addLantern(new THREE.Vector3(-2.2, -2, 2.2));
    addLantern(new THREE.Vector3(2.2, -9, -2.3));
    addLantern(new THREE.Vector3(-2.2, -18, -2.2));
  }

  function createRailsAndCart(scene) {
    const railMat = new THREE.MeshStandardMaterial({ color: 0x3f3f46, metalness: 0.45, roughness: 0.4 });
    const tieMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.85 });
    const railGeo = new THREE.BoxGeometry(9.5, 0.12, 0.18);
    const tieGeo = new THREE.BoxGeometry(0.45, 0.12, 2.2);
    const railL = new THREE.Mesh(railGeo, railMat);
    railL.position.set(0, 0.08, 2.4);
    const railR = railL.clone();
    railR.position.z = 2.9;
    scene.add(railL, railR);
    for (let i = -4; i <= 4; i++) {
      const tie = new THREE.Mesh(tieGeo, tieMat);
      tie.position.set(i * 1.05, 0.02, 2.65);
      scene.add(tie);
    }

    cartMesh = new THREE.Group();
    cartWheels = [];
    const cartBody = new THREE.Mesh(
      new THREE.BoxGeometry(1.7, 0.85, 1.2),
      new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.65, roughness: 0.3 })
    );
    cartBody.position.y = 0.6;
    const cartRim = new THREE.Mesh(
      new THREE.BoxGeometry(1.8, 0.12, 1.3),
      new THREE.MeshStandardMaterial({ color: 0xdbeafe, metalness: 0.3, roughness: 0.6 })
    );
    cartRim.position.y = 1.05;
    cartMesh.add(cartBody, cartRim);

    const wheelGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.25, 14);
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x0f172a, metalness: 0.6, roughness: 0.4 });
    const wheelPositions = [
      [-0.6, 0.25, 2.4],
      [0.6, 0.25, 2.4],
      [-0.6, 0.25, 2.9],
      [0.6, 0.25, 2.9],
    ];
    wheelPositions.forEach(([x, y, z]) => {
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI / 2;
      w.position.set(x, y, z - 2.65);
      cartMesh.add(w);
      cartWheels.push(w);
    });

    cartMesh.position.set(0, 0.2, 2.65);
    scene.add(cartMesh);
    cartOffset = 0;
    cartDirection = 1;
  }

  function buildMiner(trackGlobals = true) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.6, metalness: 0.1 });
    const skinMat = new THREE.MeshStandardMaterial({ color: 0xf5d0a3 });
    const accentMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive: 0x3b82f6 });

    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.1, 0.45), bodyMat);
    body.position.y = 0.8;
    group.add(body);

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), skinMat);
    head.position.set(0, 1.45, 0);
    group.add(head);

    const helmet = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.32, 0.2, 12), accentMat);
    helmet.position.set(0, 1.75, 0);
    group.add(helmet);

    const legGeo = new THREE.BoxGeometry(0.2, 0.7, 0.25);
    const legL = new THREE.Mesh(legGeo, bodyMat);
    legL.position.set(-0.2, 0.35, 0.05);
    const legR = legL.clone();
    legR.position.x = 0.2;
    group.add(legL, legR);

    const armGeo = new THREE.BoxGeometry(0.18, 0.6, 0.18);
    const armL = new THREE.Mesh(armGeo, skinMat);
    armL.position.set(-0.5, 1.05, 0);
    const armR = new THREE.Mesh(armGeo, skinMat);
    armR.position.set(0.5, 1.05, 0);
    group.add(armL, armR);

    const pickGeo = new THREE.BoxGeometry(0.9, 0.12, 0.12);
    const pickMat = new THREE.MeshStandardMaterial({ color: 0xb3b3b3, metalness: 0.8, roughness: 0.3 });
    const pick = new THREE.Mesh(pickGeo, pickMat);
    pick.position.set(0.6, 0, 0);
    armR.add(pick);

    group.position.set(-2.5, 0.4, 2.3);
    group.rotation.y = -Math.PI / 4;

    if (trackGlobals) {
      minerArmL = armL;
      minerArmR = armR;
      pickaxeMesh = pick;
    }

    return { group, armL, armR };
  }

  function createMinerInstance() {
    const built = buildMiner(false);
    return built;
  }

  function rebuildMinersForCurrentMine() {
    if (!scene) return;
    minerClones.forEach((c) => scene.remove(c.group));
    minerClones = [];

    const mine = getCurrentMine();
    if (!mine) return;

    const totalMiners = Math.min(mine.miners, 6);
    for (let i = 0; i < totalMiners; i++) {
      const built = createMinerInstance();
      const offsetX = -2.5 + (i % 3) * 1.2;
      const offsetY = drillMesh ? drillMesh.position.y + 0.3 + Math.floor(i / 3) * 0.5 : 0.5;
      const offsetZ = 2.3 + ((i % 2) * 0.4);
      built.group.position.set(offsetX + (Math.random() - 0.5) * 0.08, offsetY, offsetZ);
      built.group.rotation.y = -Math.PI / 4 + (i - 1) * 0.1;
      minerClones.push(built);
      scene.add(built.group);
    }
  }

  function createOreBlock(type, depth) {
    let mat;
    let geo;
    if (type === "gold") {
      mat = new THREE.MeshStandardMaterial({
        color: 0xfbbf24,
        emissive: 0x854d0e,
        emissiveIntensity: 0.35,
        metalness: 0.65,
        roughness: 0.26,
      });
      geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
    } else if (type === "oil") {
      mat = new THREE.MeshStandardMaterial({ color: 0x0f172a, metalness: 0.9, roughness: 0.12 });
      geo = new THREE.SphereGeometry(0.35, 8, 6);
    } else {
      mat = new THREE.MeshStandardMaterial({
        color: 0x7dd3fc,
        emissive: 0x38bdf8,
        emissiveIntensity: 0.7,
        roughness: 0.18,
        transparent: true,
        opacity: 0.95,
      });
      geo = new THREE.OctahedronGeometry(0.45, 0);
    }
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set((Math.random() - 0.5) * 3.8, -depth * 0.2 + (Math.random() - 0.5) * 0.8, (Math.random() > 0.5 ? 2.2 : -2.2));
    mesh.castShadow = false;
    mesh.receiveShadow = false;
    shaftGroup.add(mesh);
    oreDecorations.push({ mesh, depth });
  }

  function populateOreDecorations() {
    oreDecorations.forEach((o) => shaftGroup.remove(o.mesh));
    oreDecorations = [];
    for (let i = 0; i < 35; i++) {
      createOreBlock("gold", 5 + Math.random() * 80);
    }
    for (let i = 0; i < 25; i++) {
      createOreBlock("oil", 30 + Math.random() * 140);
    }
    for (let i = 0; i < 18; i++) {
      createOreBlock("gem", 60 + Math.random() * 220);
    }
    const pocketMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.85, metalness: 0.05 });
    for (let i = 0; i < 14; i++) {
      const geo = new THREE.BoxGeometry(0.7 + Math.random() * 0.6, 0.5 + Math.random() * 0.8, 0.6 + Math.random() * 0.5);
      const mesh = new THREE.Mesh(geo, pocketMat);
      mesh.position.set((Math.random() - 0.5) * 3.6, -(Math.random() * 110), Math.random() > 0.5 ? 2.2 : -2.2);
      mesh.rotation.z = (Math.random() - 0.5) * 0.4;
      mesh.rotation.y = (Math.random() - 0.5) * 0.6;
      shaftGroup.add(mesh);
      const depthVal = Math.abs(mesh.position.y) / 0.2;
      oreDecorations.push({ mesh, depth: depthVal });
    }
  }

  function resizeRendererToCanvas() {
    if (!renderer) return;
    const canvas = renderer.domElement;

    const rect = canvas.getBoundingClientRect();
    const width = rect.width || window.innerWidth;
    const height = rect.height || 360;

    renderer.setSize(width, height, false);
    if (camera) {
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
  }

  function initThree() {
    const canvas = document.getElementById("mine-canvas");
    canvas.height = 360;
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.domElement.style.touchAction = "none";
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;
    renderer.autoClear = false;
    renderer.setClearColor(0x020617, 1);

    const gl = renderer.getContext();
    if (!gl) {
      console.error("WebGL not available on this device.");
      const overlay = document.createElement("div");
      overlay.textContent = "WebGL not available on this device.";
      overlay.style.position = "absolute";
      overlay.style.top = "12px";
      overlay.style.left = "12px";
      overlay.style.padding = "6px 10px";
      overlay.style.background = "rgba(15,23,42,0.85)";
      overlay.style.color = "#f87171";
      overlay.style.borderRadius = "8px";
      overlay.style.fontSize = "12px";
      canvas.parentElement?.appendChild(overlay);
      return;
    }

    resizeRendererToCanvas();

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);
    scene.fog = new THREE.FogExp2(0x050816, 0.008);

    const initialWidth = canvas.clientWidth || 800;
    const initialHeight = canvas.clientHeight || 450;
    camera = new THREE.PerspectiveCamera(72, initialWidth / initialHeight, 0.1, 1000);
    camera.fov = 72;
    camera.near = 0.1;
    camera.far = 1000;
    camera.updateProjectionMatrix();

    cameraRig = new THREE.Object3D();
    cameraRig.name = "cameraRig";
    cameraRig.add(camera);
    scene.add(cameraRig);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 5;
    controls.maxDistance = 120;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.enablePan = false;

    minimapCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 80);
    minimapCamera.position.set(0, 20, 0);
    minimapCamera.lookAt(0, 0, 0);

    const hemi = new THREE.HemisphereLight(0xc3dafb, 0x21130d, 1.35);
    scene.add(hemi);
    const ambient = new THREE.AmbientLight(0x1f2937, 0.35);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xfff7d6, 2);
    dirLight.position.set(10, 16, 10);
    dirLight.castShadow = false;
    scene.add(dirLight);
    const point = new THREE.PointLight(0xfacc15, 1.4, 24);
    point.position.set(-1, 1.2, 1);
    scene.add(point);

    const groundGeo = new THREE.PlaneGeometry(14, 14);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x1f2933,
      roughness: 0.95,
      metalness: 0.05,
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.set(3, -0.1, -6);
    scene.add(ground);

    createRailsAndCart(scene);
    if (cartMesh) {
      cartMesh.name = "truck";
      truck = cartMesh;
    }

    shaftGroup = new THREE.Group();
    const strataTex = createStrataTexture();
    const wallMat = new THREE.MeshStandardMaterial({
      map: strataTex,
      roughness: 0.85,
      metalness: 0.1,
    });
    const wallMatDeep = new THREE.MeshStandardMaterial({
      map: strataTex,
      color: 0x1f2933,
      roughness: 0.9,
      metalness: 0.08,
    });
    const wallGeoX = new THREE.BoxGeometry(7, 130, 0.8);
    const wallGeoZ = new THREE.BoxGeometry(0.8, 130, 7);
    const wall1 = new THREE.Mesh(wallGeoX, wallMat);
    wall1.position.set(0, -65, -2.3);
    const wall2 = new THREE.Mesh(wallGeoX, wallMatDeep);
    wall2.position.set(0, -65, 2.3);
    const wall3 = new THREE.Mesh(wallGeoZ, wallMatDeep);
    wall3.position.set(-2.3, -65, 0);
    const wall4 = new THREE.Mesh(wallGeoZ, wallMat);
    wall4.position.set(2.3, -65, 0);
    shaftGroup.add(wall1, wall2, wall3, wall4);

    const rimGeo = new THREE.BoxGeometry(6.4, 0.4, 6.4);
    const rim = new THREE.Mesh(
      rimGeo,
      new THREE.MeshStandardMaterial({ color: 0x4a3324, roughness: 0.65, metalness: 0.08 })
    );
    rim.position.set(0, 0.2, 0);
    shaftGroup.add(rim);
    scene.add(shaftGroup);
    createSupportBeams();
    createLanterns();

    populateOreDecorations();

    const drillGroup = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.8, 16);
    const bodyMat = new THREE.MeshStandardMaterial({
      color: 0x94a3b8,
      metalness: 0.7,
      roughness: 0.3,
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1.4;
    drillGroup.add(body);

    const bitGeo = new THREE.ConeGeometry(0.5, 1.2, 16);
    const bitMat = new THREE.MeshStandardMaterial({
      color: 0xfacc15,
      metalness: 0.9,
      roughness: 0.2,
      emissive: 0x443c0f,
    });
    const bit = new THREE.Mesh(bitGeo, bitMat);
    bit.position.y = 0.4;
    bit.rotation.x = Math.PI;
    drillGroup.add(bit);

    drillGroup.position.set(0, 0.1, 0);
    scene.add(drillGroup);
    drillMesh = drillGroup;

    const markerGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const markerMat = new THREE.MeshStandardMaterial({ color: 0x7dd3fc, emissive: 0x38bdf8, emissiveIntensity: 1.3 });
    minimapMarker = new THREE.Mesh(markerGeo, markerMat);
    minimapMarker.position.set(0, 0, 0);
    scene.add(minimapMarker);

    const minerBuilt = buildMiner(true);
    minerGroup = minerBuilt.group;
    minerGroup.name = "miner";
    miner = minerGroup;
    scene.add(minerGroup);

    elevatorAnchor = new THREE.Object3D();
    elevatorAnchor.position.set(0, 1.2, 0);
    elevatorAnchor.name = "elevatorAnchor";

    // Simple elevator cage attached to the anchor, visually inside the shaft
    const elevatorGroup = new THREE.Group();
    const cageMat = new THREE.MeshStandardMaterial({
      color: 0x9ca3af,
      metalness: 0.6,
      roughness: 0.4,
    });

    const cageFrame = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.2, 1.6), cageMat);
    cageFrame.position.y = 0;

    const cageFloor = new THREE.Mesh(
      new THREE.BoxGeometry(1.6, 0.12, 1.6),
      new THREE.MeshStandardMaterial({
        color: 0x4b5563,
        metalness: 0.4,
        roughness: 0.6,
      })
    );
    cageFloor.position.y = -0.6;

    elevatorGroup.add(cageFrame, cageFloor);
    elevatorGroup.position.set(0, 0, 0);

    // Parent the visible elevator to the anchor, and the anchor to the shaft group
    elevatorAnchor.add(elevatorGroup);
    shaftGroup.add(elevatorAnchor);

    minerAnchor = new THREE.Object3D();
    minerAnchor.name = "minerAnchor";
    truckAnchor = new THREE.Object3D();
    truckAnchor.name = "truckAnchor";
    overviewAnchor = new THREE.Object3D();
    overviewAnchor.name = "overviewAnchor";
    scene.add(minerAnchor, truckAnchor, overviewAnchor);
    rebuildMinersForCurrentMine();

    // Initialize camera to a sensible default overview framing.
    syncCameraAnchors();
    setCameraPreset("overview");
    updateCameraForActivePreset();

    window.addEventListener("resize", resizeRendererToCanvas);

    canvas.addEventListener("click", onCanvasClick);
  }

  function spawnDust() {
    if (!drillMesh) return;
    const origin = drillMesh.position.clone();
    for (let i = 0; i < 8; i++) {
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 5, 5), dustMaterial);
      mesh.position.copy(origin);
      mesh.position.x += (Math.random() - 0.5) * 0.8;
      mesh.position.z += (Math.random() - 0.5) * 0.8;
      shaftGroup.add(mesh);
      dustParticles.push({
        mesh,
        vel: new THREE.Vector3((Math.random() - 0.5) * 1.4, 1 + Math.random() * 1.5, (Math.random() - 0.5) * 1.4),
        life: 0.9,
      });
    }
  }

  function updateDust(dt) {
    dustParticles = dustParticles.filter((p) => {
      p.life -= dt;
      p.mesh.position.addScaledVector(p.vel, dt);
      p.vel.y -= dt * 2.5;
      if (p.life <= 0) {
        shaftGroup.remove(p.mesh);
        return false;
      }
      return true;
    });
  }

  function animateLanterns(dt) {
    lanterns.forEach((lan) => {
      lan.phase += dt * 2.4;
      const flicker = 1 + Math.sin(lan.phase) * 0.18 + Math.random() * 0.08;
      lan.light.intensity = 1.1 * flicker;
      lan.mesh.rotation.z = Math.sin(lan.phase * 0.7) * 0.04;
    });
  }

  function animateCart(dt) {
    if (!cartMesh) return;
    const truckLevel = state.logistics.truckLevel || 1;
    const baseSpeed = 2.1 * (state.logistics.truckSpeedBase || 1);
    const speedBoost = truckBoostTimer > 0 ? 1.7 : 1;
    const speed = baseSpeed * speedBoost * (1 + 0.2 * (truckLevel - 1));
    const capacity = state.logistics.truckCapacityBase * (1 + 0.6 * (truckLevel - 1));
    cartOffset += dt * cartDirection * speed;
    const maxOffset = 3.5;
    if (cartOffset > maxOffset) {
      cartOffset = maxOffset;
      if (truckState.hasLoad && state.oreFlow.truckLoad > 0) {
        state.money += state.oreFlow.truckLoad;
        spawnFloatingTextNearTruck(`+${state.oreFlow.truckLoad.toFixed(1)} üí∞`);
        soundManager.playMoney();
        state.oreFlow.truckLoad = 0;
        truckState.hasLoad = false;
        updateStatsUI();
      }
      cartDirection = -1;
    } else if (cartOffset < -maxOffset) {
      cartOffset = -maxOffset;
      if (truckState.hasLoad && state.oreFlow.truckLoad > 0) {
        state.money += state.oreFlow.truckLoad;
        spawnFloatingTextNearTruck(`+${state.oreFlow.truckLoad.toFixed(1)} üí∞`);
        soundManager.playMoney();
        state.oreFlow.truckLoad = 0;
        truckState.hasLoad = false;
        updateStatsUI();
      }
      cartDirection = 1;
    }

    if (!truckState.hasLoad && Math.abs(cartOffset) < 0.3 && state.oreFlow.surfaceOre > 0) {
      const loadAmount = Math.min(capacity, state.oreFlow.surfaceOre);
      state.oreFlow.surfaceOre -= loadAmount;
      state.oreFlow.truckLoad = loadAmount;
      truckState.hasLoad = true;
      log(`Truck loaded ${loadAmount.toFixed(1)} ore.`);
    }

    cartMesh.position.x = cartOffset;
    cartMesh.rotation.y = cartDirection === 1 ? Math.PI : 0;
    cartWheels.forEach((w) => (w.rotation.z += dt * 6 * cartDirection));
  }

  function updateElevator(dt) {
    if (!elevatorAnchor || !drillMesh) return;
    const surfaceY = 1.2;
    const bottomY = THREE.MathUtils.clamp(drillMesh.position.y + 1.0, -55, surfaceY - 1.5);
    const elevLevel = state.logistics.elevatorLevel || 1;
    const speed = (state.logistics.elevatorSpeedBase || 1) * (1 + 0.25 * (elevLevel - 1));
    const capacity = state.logistics.elevatorCapacityBase * (1 + 0.5 * (elevLevel - 1));

    switch (elevatorState.mode) {
      case "idle_surface":
        elevatorAnchor.position.y = THREE.MathUtils.lerp(elevatorAnchor.position.y, surfaceY, 0.6 * dt);
        if (state.oreFlow.shaftOre > 10) {
          elevatorState.mode = "moving_down";
          elevatorState.progress = 0;
        }
        break;
      case "moving_down":
        elevatorAnchor.position.y = THREE.MathUtils.lerp(elevatorAnchor.position.y, bottomY, speed * dt);
        if (Math.abs(elevatorAnchor.position.y - bottomY) < 0.2) {
          elevatorState.mode = "loading";
          elevatorState.progress = 0;
        }
        break;
      case "loading":
        elevatorState.progress += dt;
        if (elevatorState.progress > 0.6) {
          const free = capacity - state.oreFlow.elevatorLoad;
          const take = Math.min(free, state.oreFlow.shaftOre);
          state.oreFlow.shaftOre -= take;
          state.oreFlow.elevatorLoad += take;
          elevatorState.mode = "moving_up";
          elevatorState.progress = 0;
        }
        break;
      case "moving_up":
        elevatorAnchor.position.y = THREE.MathUtils.lerp(elevatorAnchor.position.y, surfaceY, speed * dt);
        if (Math.abs(elevatorAnchor.position.y - surfaceY) < 0.15) {
          elevatorState.mode = "unloading";
          elevatorState.progress = 0;
        }
        break;
      case "unloading":
        elevatorState.progress += dt;
        if (elevatorState.progress > 0.4) {
          state.oreFlow.surfaceOre += state.oreFlow.elevatorLoad;
          state.oreFlow.elevatorLoad = 0;
          elevatorState.mode = "idle_surface";
          elevatorState.progress = 0;
        }
        break;
    }
  }

  function updateOreVisibility() {
    const mine = getCurrentMine();
    const depth = mine ? mine.depth : 0;
    oreDecorations.forEach((o) => {
      o.mesh.visible = depth + 4 >= o.depth;
      if (o.mesh.visible) {
        o.mesh.material.emissiveIntensity = 0.6;
      }
    });
  }

  function projectToScreen(pos) {
    if (!camera || !renderer) return { x: 0, y: 0 };
    const rect = renderer.domElement.getBoundingClientRect();
    tempVec.copy(pos).project(camera);
    return {
      x: (tempVec.x * 0.5 + 0.5) * rect.width,
      y: (-tempVec.y * 0.5 + 0.5) * rect.height,
    };
  }

  function spawnFloatingTextFromGains(gains) {
    if (!floatingContainer) return;
    const pos = drillMesh ? drillMesh.getWorldPosition(new THREE.Vector3()) : new THREE.Vector3();
    const screen = projectToScreen(pos);
    const entries = [];
    if (gains.oreValue > 0) entries.push({ text: `+${gains.oreValue.toFixed(1)} ore`, color: "#facc15" });
    if (gains.goldGain > 0.2) entries.push({ text: `+${gains.goldGain.toFixed(1)} ü™ô`, color: "#fbbf24" });
    if (gains.oilGain > 0.2) entries.push({ text: `+${gains.oilGain.toFixed(1)} üõ¢Ô∏è`, color: "#cbd5f5" });
    if (gains.gemGain > 0) entries.push({ text: `+${gains.gemGain.toFixed(2)} üíé`, color: "#7dd3fc" });

    entries.forEach((entry, idx) => {
      const el = document.createElement("div");
      el.className = "floating-text";
      const clampedX = Math.min(floatingContainer.clientWidth - 12, Math.max(12, screen.x));
      const clampedY = Math.min(floatingContainer.clientHeight - 12, Math.max(12, screen.y - idx * 14 - 10));
      el.style.left = `${clampedX}px`;
      el.style.top = `${clampedY}px`;
      el.style.color = entry.color;
      el.textContent = entry.text;
      floatingContainer.appendChild(el);
      requestAnimationFrame(() => {
        el.style.opacity = 1;
        el.style.transform = `translate(-50%, -60%) translateY(-10px)`;
      });
      setTimeout(() => {
        el.style.opacity = 0;
        el.remove();
      }, 900);
    });
  }

  function spawnFloatingTextNearTruck(text) {
    if (!floatingContainer || !cartMesh) return;
    const pos = cartMesh.getWorldPosition(new THREE.Vector3());
    const screen = projectToScreen(pos);
    const el = document.createElement("div");
    el.className = "floating-text";
    el.style.left = `${screen.x}px`;
    el.style.top = `${screen.y - 14}px`;
    el.style.color = "#facc15";
    el.textContent = text;
    floatingContainer.appendChild(el);
    requestAnimationFrame(() => {
      el.style.opacity = 1;
      el.style.transform = `translate(-50%, -60%) translateY(-10px)`;
    });
    setTimeout(() => {
      el.style.opacity = 0;
      el.remove();
    }, 900);
  }

  function spawnRipple() {
    if (!floatingContainer) return;
    const pos = drillMesh ? drillMesh.getWorldPosition(new THREE.Vector3()) : new THREE.Vector3();
    const screen = projectToScreen(pos);
    const el = document.createElement("div");
    el.className = "dig-ripple";
    el.style.left = `${screen.x}px`;
    el.style.top = `${screen.y}px`;
    floatingContainer.appendChild(el);
    setTimeout(() => el.remove(), 950);
  }

  function animateMiner(dt) {
    if (!minerGroup) return;
    if (minerDigTimer > 0) {
      minerDigTimer -= dt;
      const swing = Math.sin(Math.max(minerDigTimer, 0) * Math.PI * 6) * 0.9;
      minerArmR.rotation.z = -swing;
      minerArmL.rotation.z = swing * 0.4;
      minerGroup.position.x = -2.5 + swing * 0.05;
    } else {
      autoDigTimer += dt * (1 + state.autoRate * 0.05);
      const swing = Math.sin(autoDigTimer * 2) * 0.2;
      minerArmR.rotation.z = swing;
      minerArmL.rotation.z = -swing * 0.5;
    }

    minerClones.forEach((m, idx) => {
      const swing = Math.sin((autoDigTimer + idx * 0.2) * 2) * 0.3;
      if (m.armR && m.armL) {
        m.armR.rotation.z = swing;
        m.armL.rotation.z = -swing * 0.5;
      }
      if (drillMesh) {
        m.group.position.y = drillMesh.position.y + 0.3 + Math.floor(idx / 3) * 0.5;
      }
    });
  }

  function getCameraPositionForRadius(target, radius, heightMultiplier = 1.0) {
    const angle = Math.PI * 0.25;
    const distance = radius * 2.2;
    const x = target.x + distance * Math.cos(angle);
    const z = target.z + distance * Math.sin(angle);
    const y = Math.max(4, target.y + radius * heightMultiplier);

    return new THREE.Vector3(x, y, z);
  }

  function syncCameraAnchors() {
    if (!minerAnchor) return;
    if (minerGroup) minerGroup.getWorldPosition(minerAnchor.position);
    if (cartMesh) cartMesh.getWorldPosition(truckAnchor.position);
  }

  function refreshOverviewAnchor() {
    if (!overviewAnchor) return;
    const box = new THREE.Box3();
    let initialized = false;

    if (minerGroup) {
      box.setFromObject(minerGroup);
      initialized = true;
    } else if (minerAnchor) {
      box.setFromCenterAndSize(minerAnchor.position, new THREE.Vector3(0.1, 0.1, 0.1));
      initialized = true;
    }

    if (cartMesh) {
      if (!initialized) {
        box.setFromObject(cartMesh);
        initialized = true;
      } else {
        box.expandByObject(cartMesh);
      }
    }

    if (elevatorAnchor) {
      if (!initialized) {
        box.setFromObject(elevatorAnchor);
        initialized = true;
      } else {
        box.expandByObject(elevatorAnchor);
      }
    }

    if (!initialized) {
      box.setFromCenterAndSize(new THREE.Vector3(0, -2, 0), new THREE.Vector3(8, 8, 8));
    }
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const radius = Math.max(size.x, size.z, size.y) * 0.9 || 10;

    overviewAnchor.position.copy(center);
    return radius;
  }

  function setOverviewCamera() {
    cameraState.mode = "overview";
    const radius = refreshOverviewAnchor() || 10;
    cameraState.target.copy(overviewAnchor.position);
    cameraState.desiredPosition.copy(
      getCameraPositionForRadius(overviewAnchor.position, radius, 1.6)
    );
  }

  function setMinerCamera() {
    cameraState.mode = "miner";
    cameraState.target.copy(minerAnchor.position);
    cameraState.desiredPosition.copy(
      minerAnchor.position.clone().add(new THREE.Vector3(8, 6, 10))
    );
  }

  function setTruckCamera() {
    cameraState.mode = "truck";
    cameraState.target.copy(truckAnchor.position);
    cameraState.desiredPosition.copy(
      truckAnchor.position.clone().add(new THREE.Vector3(-10, 7, 12))
    );
  }

  function setElevatorCamera() {
    cameraState.mode = "elevator";
    cameraState.target.copy(elevatorAnchor.position);
    cameraState.desiredPosition.copy(
      elevatorAnchor.position.clone().add(new THREE.Vector3(6, 12, 6))
    );
  }

  function setCameraPreset(preset) {
    const mode = preset || "overview";
    switch (mode) {
      case "miner":
        setMinerCamera();
        break;
      case "truck":
        setTruckCamera();
        break;
      case "elevator":
        setElevatorCamera();
        break;
      case "overview":
      default:
        setOverviewCamera();
        break;
    }
    cameraState.currentTarget.copy(cameraState.target);
    if (cameraRig) {
      cameraRig.position.copy(cameraState.desiredPosition);
    }
  }

  function updateCameraForActivePreset(dt) {
    if (!cameraRig || !camera) return;

    if (cameraState.lockToAction) {
      if (cameraState.mode === "miner") {
        cameraState.target.copy(minerAnchor.position);
      } else if (cameraState.mode === "truck") {
        cameraState.target.copy(truckAnchor.position);
      } else if (cameraState.mode === "elevator") {
        cameraState.target.copy(elevatorAnchor.position);
      } else if (cameraState.mode === "overview") {
        const radius = refreshOverviewAnchor() || 12;
        cameraState.desiredPosition.copy(
          getCameraPositionForRadius(overviewAnchor.position, radius, 1.6)
        );
      }
    }

    const lerpFactor = 0.08;
    cameraRig.position.lerp(cameraState.desiredPosition, lerpFactor);
    cameraState.currentTarget.lerp(cameraState.target, lerpFactor);

    camera.lookAt(cameraState.currentTarget);
    if (controls) {
      if (cameraState.lockToAction) {
        controls.target.copy(cameraState.currentTarget);
      }
      controls.update();
    }
  }

  function handleSceneClick(obj) {
    let node = obj;
    let clickedMiner = false;
    let clickedTruck = false;
    while (node) {
      if (node === minerGroup) clickedMiner = true;
      if (node === cartMesh) clickedTruck = true;
      node = node.parent;
    }

    if (clickedMiner) {
      minerBoostTimer = 2.0;
      log("Miner is digging faster for a moment!");
    } else if (clickedTruck) {
      truckBoostTimer = 2.0;
      log("Truck speed boosted! Hauling faster.");
    }
  }

  function onCanvasClick(e) {
    if (!scene || !camera || !renderer) return;
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length === 0) return;
    handleSceneClick(intersects[0].object);
  }

  function updateThree(dt) {
    if (!scene || !camera || !renderer) return;
    const mine = getCurrentMine();
    const depthVal = mine ? mine.depth : 0;
    updateOreVisibility();
    updateDust(dt);
    animateMiner(dt);
    animateLanterns(dt);
    animateCart(dt);

    const maxVisualDepth = 200;
    const depthRatio = Math.min(1, depthVal / maxVisualDepth);
    depthTargetY = -Math.min(depthVal * 0.16, 55);

    minimapCamera.position.y = THREE.MathUtils.lerp(minimapCamera.position.y, 18 + depthRatio * 3, 0.1);

    if (shaftGroup) {
      shaftGroup.position.y = THREE.MathUtils.lerp(shaftGroup.position.y || 0, depthTargetY, 0.15);
    }
    if (drillMesh) {
      drillMesh.position.y = THREE.MathUtils.lerp(drillMesh.position.y, depthTargetY + 0.4, 0.2);
      drillMesh.rotation.y += dt * 2 * (1 + state.autoRate * 0.15);
      if (digPulse > 0) {
        drillMesh.position.y += Math.sin((1 - digPulse) * Math.PI * 3) * 0.2;
      }
    }
    updateElevator(dt);
    if (minerGroup) {
      minerGroup.position.y = drillMesh.position.y + 0.3;
    }

    if (minimapMarker && drillMesh) {
      minimapMarker.position.copy(drillMesh.position);
      minimapMarker.position.y += 0.5;
    }

    if (digPulse > 0) {
      digPulse -= dt * 2.5;
      if (digPulse < 0) digPulse = 0;
    }

    syncCameraAnchors();
    updateCameraForActivePreset(dt);
    const pr = renderer.getPixelRatio();
    const viewW = renderer.domElement.clientWidth * pr;
    const viewH = renderer.domElement.clientHeight * pr;

    renderer.setViewport(0, 0, viewW, viewH);
    renderer.setScissor(0, 0, viewW, viewH);
    renderer.setScissorTest(true);
    renderer.clear();
    renderer.render(scene, camera);

    const miniW = viewW * 0.32;
    const miniH = viewH * 0.32;
    renderer.setViewport(viewW - miniW - 10 * pr, viewH - miniH - 10 * pr, miniW, miniH);
    renderer.setScissor(viewW - miniW - 10 * pr, viewH - miniH - 10 * pr, miniW, miniH);
    renderer.render(scene, minimapCamera);
  }

  // ===================== Supabase sync =====================
  async function ensureProfileExists() {
    if (!state.playerName) return;
    if (state.playerId) return;
    try {
      const { data, error } = await supabase
        .from("mg_players")
        .insert({
          name: state.playerName,
          best_depth: bestDepthAcrossMines(),
          total_gold: state.gold,
          room_code: state.roomCode || null,
          last_online: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) {
        supabaseOnline = false;
        lastSyncError = error.message;
        updateOnlineStatusUI();
        return;
      }
      state.playerId = data.id;
      state.bestDepthSynced = data.best_depth || 0;
      supabaseOnline = true;
      lastSyncError = null;
      updateOnlineStatusUI();
      saveLocalState();
    } catch (e) {
      supabaseOnline = false;
      lastSyncError = e.message;
      updateOnlineStatusUI();
    }
  }

  async function syncProfile() {
    if (!sessionStarted) return;
    if (!state.playerName) return;

    await ensureProfileExists();
    if (!state.playerId) return;

    try {
      const { error } = await supabase
        .from("mg_players")
        .update({
          best_depth: bestDepthAcrossMines(),
          total_gold: state.gold,
          room_code: state.roomCode || null,
          last_online: new Date().toISOString(),
        })
        .eq("id", state.playerId);

      if (error) {
        supabaseOnline = false;
        lastSyncError = error.message;
      } else {
        supabaseOnline = true;
        lastSyncError = null;
        state.bestDepthSynced = bestDepthAcrossMines();
      }
      updateOnlineStatusUI();
      saveLocalState();
    } catch (e) {
      supabaseOnline = false;
      lastSyncError = e.message;
      updateOnlineStatusUI();
    }
  }

  async function loadLeaderboard() {
    if (!supabaseOnline && state.playerId == null) return;

    try {
      let query = supabase
        .from("mg_players")
        .select("*")
        .order("best_depth", { ascending: false })
        .limit(50);

      if (leaderboardMode === "room" && state.roomCode) {
        query = query.eq("room_code", state.roomCode);
      }

      const { data, error } = await query;

      if (error) {
        supabaseOnline = false;
        lastSyncError = error.message;
        updateOnlineStatusUI();
        return;
      }

      supabaseOnline = true;
      lastSyncError = null;
      updateOnlineStatusUI();

      renderLeaderboard(data || []);
      renderDepthRuler(data || []);
    } catch (e) {
      supabaseOnline = false;
      lastSyncError = e.message;
      updateOnlineStatusUI();
    }
  }

  function renderLeaderboard(players) {
    leaderboardListEl.innerHTML = "";
    if (!players.length) {
      const empty = document.createElement("div");
      empty.textContent = "No players yet.";
      empty.style.color = "#9ca3af";
      empty.style.fontSize = "0.8rem";
      leaderboardListEl.appendChild(empty);
      return;
    }

    players.forEach((p, idx) => {
      const row = document.createElement("div");
      row.className = "lb-row";
      if (state.playerId && p.id === state.playerId) {
        row.classList.add("me");
      }

      const rank = document.createElement("div");
      rank.className = "lb-rank";
      rank.textContent = `${idx + 1}.`;

      const nameCell = document.createElement("div");
      nameCell.className = "lb-name";
      const nameSpan = document.createElement("span");
      nameSpan.textContent = p.name || "Anon";
      nameCell.appendChild(nameSpan);

      if (state.playerId && p.id === state.playerId) {
        const meChip = document.createElement("span");
        meChip.className = "me-chip";
        meChip.textContent = "Sen";
        nameCell.appendChild(meChip);
      }
      if (p.room_code) {
        const rc = document.createElement("span");
        rc.className = "room-code-pill";
        rc.textContent = p.room_code;
        nameCell.appendChild(rc);
      }

      const depthCell = document.createElement("div");
      depthCell.className = "lb-depth";
      depthCell.textContent = `${Number(p.best_depth || 0).toFixed(1)} m`;

      row.appendChild(rank);
      row.appendChild(nameCell);
      row.appendChild(depthCell);
      leaderboardListEl.appendChild(row);
    });
  }

  function renderDepthRuler(players) {
    const markers = depthRulerEl.querySelectorAll(".depth-marker");
    markers.forEach(m => m.remove());

    if (!players.length) return;

    let maxDepth = players.reduce(
      (max, p) => Math.max(max, Number(p.best_depth || 0)),
      0
    );
    if (maxDepth < 1) maxDepth = 1;

    players.slice(0, 20).forEach(p => {
      const depth = Number(p.best_depth || 0);
      const ratio = depth / maxDepth;
      const bottomPercent = 5 + ratio * 90;

      const marker = document.createElement("div");
      marker.className = "depth-marker";
      if (state.playerId && p.id === state.playerId) {
        marker.classList.add("me");
      }
      marker.style.bottom = `${bottomPercent}%`;

      const dot = document.createElement("div");
      dot.className = "dot";
      const label = document.createElement("div");
      label.className = "label";
      label.textContent = `${p.name || "Anon"} ¬∑ ${depth.toFixed(0)} m`;

      marker.appendChild(dot);
      marker.appendChild(label);
      depthRulerEl.appendChild(marker);
    });
  }

  // ===================== Session / setup =====================
  function applyRoomLabel() {
    if (state.roomCode) {
      roomLabel.textContent = `Room: ${state.roomCode}`;
    } else {
      roomLabel.textContent = "Global leaderboard";
    }
  }

  function startSession() {
    if (!state.playerName) {
      setupErrorEl.textContent = "Please enter your name.";
      return;
    }
    setupErrorEl.textContent = "";
    sessionStarted = true;
    recalcDerivedStats();
    updateStatsUI();
    applyRoomLabel();
    saveLocalState();

    setupSection.style.display = "none";
    gameSection.style.display = "block";

    // Oyun b√∂l√ºm√º g√∂r√ºn√ºr olduktan sonra canvas boyutunu d√ºzelt
    resizeRendererToCanvas();

    // Reset to overview when the game actually starts
    setCameraPreset("overview");
    updateCameraForActivePreset();

    log(`Welcome ${state.playerName}! you can start digging.`);
    if (state.roomCode) {
      log(`Room code: ${state.roomCode}. Share it with friends to play together.`);
    }

    // Try to sync & load leaderboard
    syncProfile();
    loadLeaderboard();
  }

  // ===================== Events =====================
  btnStartSolo.addEventListener("click", () => {
    markInteraction();
    const name = playerNameInput.value.trim();
    if (!name) {
      setupErrorEl.textContent = "Please enter your name.";
      return;
    }
    state.playerName = name;
    // global, no room code
    startSession();
  });

  btnJoinRoom.addEventListener("click", () => {
    markInteraction();
    const name = playerNameInput.value.trim();
    const code = roomCodeInput.value.trim().toUpperCase();
    if (!name) {
      setupErrorEl.textContent = "Please enter your name.";
      return;
    }
    if (!code) {
      setupErrorEl.textContent = "Room code cannot be empty.";
      return;
    }
    state.playerName = name;
    state.roomCode = code;
    createdRoomCodeEl.style.display = "none";
    startSession();
  });

  btnCreateRoom.addEventListener("click", () => {
    markInteraction();
    const name = playerNameInput.value.trim();
    if (!name) {
      setupErrorEl.textContent = "Enter a name before creating a room.";
      return;
    }
    state.playerName = name;
    const slug = Math.random().toString(36).substring(2, 7).toUpperCase();
    state.roomCode = slug;
    createdRoomCodeEl.style.display = "inline-block";
    createdRoomCodeEl.textContent = `Room code: ${slug}`;
    setupErrorEl.textContent = "After creating a room you can just start; friends who join with the code will share the leaderboard.";
  });

  btnLanguage.addEventListener("click", () => {
    markInteraction();
    state.language = state.language === "en" ? "tr" : "en";
    btnLanguage.textContent = state.language === "en" ? "üá¨üáß EN" : "üáπüá∑ TR";
    applyLanguage();
    updateStatsUI();
    updateEventUI();
    updateOnlineStatusUI();
    saveLocalState();
  });

  btnDig.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    if (isCollapseActive()) {
      log("Digging during a cave-in is risky, repair first!");
      return;
    }
    const gains = applyMining(state.perClick * miningBoostMultiplier(), false);
    minerDigTimer = 0.4;
    digPulse = 1;
    shakeStrength = Math.min(1.2, 0.1 + state.perClick * 0.04);
    shakeTime = 0.35;
    spawnDust();
    spawnRipple();
    spawnFloatingTextFromGains(gains);
    soundManager.playDig();
    if (gains.oreValue > 15) soundManager.playMoney();
    if (gains.gemGain > 0) soundManager.playGem();
    updateStatsUI();
    saveLocalState();
  });

  btnUpgradeAxe.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    const mine = getCurrentMine();
    const cost = axeCost(mine.axeLevel);
    if (!spend(cost)) {
      log("Not enough cash (Pickaxe upgrade).");
      return;
    }
    mine.axeLevel += 1;
    recalcDerivedStats();
    log(`${mine.name} kazma seviyesi ${mine.axeLevel} oldu.`);
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  btnHireMiner.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    const mine = getCurrentMine();
    const cost = minerCost(mine.miners);
    if (!spend(cost)) {
      log("Yeterli paran yok (Worker kiralama).");
      return;
    }
    mine.miners += 1;
    recalcDerivedStats();
    rebuildMinersForCurrentMine();
    log(`${mine.name}  hired a new worker. Total: ${mine.miners}.`);
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  btnUpgradeDrill.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    const mine = getCurrentMine();
    const cost = drillCost(mine.drillLevel);
    if (!spend(cost)) {
      log("Yeterli paran yok (Matkap kulesi).");
      return;
    }
    mine.drillLevel += 1;
    recalcDerivedStats();
    log(`${mine.name} matkap seviyesi ${mine.drillLevel} oldu.`);
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  btnUpgradeRadar.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    const mine = getCurrentMine();
    const cost = radarCost(mine.radarLevel);
    if (!spend(cost)) {
      log("Yeterli paran yok (Geo Radar).");
      return;
    }
    mine.radarLevel += 1;
    recalcDerivedStats();
    log(`${mine.name} jeo-radar seviyesi ${mine.radarLevel} oldu.`);
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  btnUpgradeEfficiency.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    const mine = getCurrentMine();
    const cost = efficiencyCost(mine.efficiencyLevel);
    if (!spend(cost)) {
      log("Yeterli paran yok (Verimlilik).");
      return;
    }
    mine.efficiencyLevel += 1;
    recalcDerivedStats();
    log(`${mine.name} extraction efficiency ${mine.efficiencyLevel} oldu.`);
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  function spendSpecial(cost) {
    if (state.gold < (cost.gold || 0) || state.gems < (cost.gems || 0)) return false;
    state.gold -= cost.gold || 0;
    state.gems -= cost.gems || 0;
    return true;
  }

  btnUpgradeElevator.addEventListener("click", () => {
    if (!sessionStarted || state.specialUpgrades.elevator) return;
    markInteraction();
    if (!spendSpecial({ gold: 300, gems: 20 })) {
      log("Not enough gold/gems for the elevator.");
      return;
    }
    state.specialUpgrades.elevator = true;
    state.logistics.elevatorLevel = (state.logistics.elevatorLevel || 1) + 1;
    state.logistics.elevatorCapacityBase *= 1.1;
    recalcDerivedStats();
    log("Endless Elevator installed! Auto-digging is faster.");
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  btnUpgradeStabilizer.addEventListener("click", () => {
    if (!sessionStarted || state.specialUpgrades.stabilizer >= 1) return;
    markInteraction();
    if (!spendSpecial({ gold: 250, gems: 10 })) {
      log("Not enough resources for the stabilizer.");
      return;
    }
    state.specialUpgrades.stabilizer = 1;
    log("Blast Stabilizer installed. Cave-in penalty reduced.");
    soundManager.playUpgrade();
    saveLocalState();
    updateStatsUI();
  });

  btnUpgradeCrystalLab.addEventListener("click", () => {
    if (!sessionStarted || state.specialUpgrades.crystalLab) return;
    markInteraction();
    if (!spendSpecial({ gold: 500, gems: 35 })) {
      log("Crystal Intelligence insufficient resources.");
      return;
    }
    state.specialUpgrades.crystalLab = true;
    log("Crystal Intelligence unlocked. Gem discovery increased!");
    soundManager.playUpgrade();
    saveLocalState();
    updateStatsUI();
  });

  btnUpgradeLuxury.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    if (!spendSpecial({ gold: 100, gems: 5 })) {
      log("Not enough resources for Luxury Gear.");
      return;
    }
    state.specialUpgrades.luxury += 1;
    recalcDerivedStats();
    log(`Luxury Gear seviyesi ${state.specialUpgrades.luxury} oldu.`);
    soundManager.playUpgrade();
    saveLocalState();
    updateStatsUI();
  });

  btnToggleSfx.addEventListener("click", () => {
    markInteraction();
    soundManager.toggleMute();
    saveLocalState();
  });

  btnToggleMusic.addEventListener("click", () => {
    markInteraction();
    soundManager.toggleMusic();
    saveLocalState();
  });

  btnCharge.addEventListener("click", () => {
    if (!sessionStarted) return;
    markInteraction();
    if (nextChargeReadyInMs() > 0 && !isChargeActive()) return;
    const duration = 5000;
    const mine = getCurrentMine();
    const cooldown = Math.max(8000, 16000 - mine.drillLevel * 400 - mine.radarLevel * 200);
    state.chargeActiveUntil = Date.now() + duration;
    state.chargeReadyAt = Date.now() + cooldown;
    recalcDerivedStats();
    log("Explosive charge active! Earnings multiplied.");
    soundManager.playUpgrade();
    updateStatsUI();
    saveLocalState();
  });

  btnViewGlobal.addEventListener("click", () => {
    leaderboardMode = "global";
    btnViewGlobal.classList.add("active");
    btnViewRoom.classList.remove("active");
    loadLeaderboard();
  });

  btnViewRoom.addEventListener("click", () => {
    leaderboardMode = "room";
    btnViewRoom.classList.add("active");
    btnViewGlobal.classList.remove("active");
    loadLeaderboard();
  });

  btnRefreshLeaderboard.addEventListener("click", () => {
    loadLeaderboard();
  });

  cameraButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const preset = btn.getAttribute("data-preset");
      setCameraPreset(preset);
      log(`Camera preset: ${preset}`);
    });
  });

  function updateLockButtonUI() {
    if (!btnToggleLock) return;
    btnToggleLock.textContent = cameraState.lockToAction ? "Unlock Camera" : "Lock Camera";
    btnToggleLock.classList.toggle("active", cameraState.lockToAction);
  }

  if (btnToggleLock) {
    btnToggleLock.addEventListener("click", () => {
      cameraState.lockToAction = !cameraState.lockToAction;
      if (cameraState.lockToAction) {
        updateCameraForActivePreset();
      }
      updateLockButtonUI();
      log(cameraState.lockToAction ? "Camera locked to action" : "Camera unlocked (free orbit)");
    });
    updateLockButtonUI();
  }

  window.addEventListener("keydown", (e) => {
    switch (e.key) {
      case "1":
        setCameraPreset("overview");
        updateLockButtonUI();
        break;
      case "2":
        setCameraPreset("miner");
        updateLockButtonUI();
        break;
      case "3":
        setCameraPreset("truck");
        updateLockButtonUI();
        break;
      case "4":
        setCameraPreset("elevator");
        updateLockButtonUI();
        break;
      case "l":
      case "L":
        cameraState.lockToAction = !cameraState.lockToAction;
        updateLockButtonUI();
        log(cameraState.lockToAction ? "Camera locked to action" : "Camera unlocked (free orbit)");
        break;
    }
  });

  btnRepair.addEventListener("click", () => {
    if (!isCollapseActive()) return;
    const cost = { money: 200, oil: 100 };
    if (state.money < cost.money || state.oil < cost.oil) {
      log("Not enough cash/oil to repair.");
      return;
    }
    state.money -= cost.money;
    state.oil -= cost.oil;
    resolveCollapse(true);
  });

  // ===================== Game loop =====================
  function loop(now) {
    const dt = Math.min((now - lastFrameTime) / 1000, 0.05);
    lastFrameTime = now;

    soundManager.update(dt);
    updateBoostTimers(dt);

    if (sessionStarted) {
      const chargeActive = isChargeActive();
      if (prevChargeActive && !chargeActive) {
        recalcDerivedStats();
      }
      prevChargeActive = chargeActive;
      maybeTriggerCollapse(dt);

      const collapseActive = isCollapseActive();
      if (state.autoRate > 0 && !collapseActive) {
        const gains = applyMining(state.autoRate * dt * miningBoostMultiplier(), true);
        minerDigTimer = Math.max(minerDigTimer, 0.18);

        // Auto-dig sƒ±rasƒ±nda ses √ßalmayalƒ±m, sadece g√∂rsel animasyon olsun
        // if (gains.gemGain > 0 && Math.random() < 0.15) soundManager.playGem();
      }
      if (state.currentEvent.type === "collapse" && Date.now() > state.currentEvent.endsAt) {
        resolveCollapse(false);
      }
      updateStatsUI();
    }

    updateThree(dt);
    requestAnimationFrame(loop);
  }

  function startMainLoop() {
    lastFrameTime = performance.now();
    requestAnimationFrame(loop);
  }

  // periodic save + sync
  setInterval(() => {
    if (!sessionStarted) return;
    saveLocalState();
    syncProfile();
    if (Math.random() < 0.4) {
      loadLeaderboard();
    }
  }, 15000);

  window.addEventListener("beforeunload", () => {
    saveLocalState();
  });

  // ===================== Init =====================
  window.addEventListener("DOMContentLoaded", () => {
    window.addEventListener("pointerdown", () => markInteraction(), { once: true });
    loadLocalState();
    applyLanguage();
    updateOnlineStatusUI();
    recalcDerivedStats();
    updateStatsUI();
    renderMineTabs();
    soundManager.updateMusicState();
    if (state.playerName) {
      playerNameInput.value = state.playerName;
    }
    if (state.roomCode) {
      roomCodeInput.value = state.roomCode;
    }

    initThree();
    setCameraPreset("overview");
    resizeRendererToCanvas();
    startMainLoop();
  });
</script>
</body>
</html>
